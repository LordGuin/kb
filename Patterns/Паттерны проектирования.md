# Паттерны проектирования

------

Термин «design patterns» можно перевести с английского как паттерны/шаблоны/образцы проектирования. Они применяются в процессе создания информационных систем и являются формализованными описаниями регулярно возникающих задач проектирования, эффективными решениями таких задач и рекомендациями по использованию полученных решений в тех или иных ситуациях.

Однако, как уже отмечалось ранее, паттерны проектирования отличаются от архитектурных паттернов степенью детализации. В отличие от архитектурных паттернов, паттерны проектирования описывают схемы детализации программных подсистем и их отношений между собой. Такие паттерны никак не влияют на структуру программной системы в целом и не зависят от использования языка программирования.

Рассказать о всех паттернах проектирования подробно в одном документе не выйдет. Чтобы глуб;tознакомиться со всеми паттернами советую ознакомится с книгой «Design Patterns: Elements of Reusable Object-Oriented Software»  Э. Гамма, Р. Хелм, Р. Джонсону и Д. Влиссидесу(или "банда четырех"-*Gang Of Four*). Авторы осмыслили концепцию паттернов  и выделили 23 паттерна проектирования, которые которые активно используются и в современной разработки. Выделяют три типа паттернов проектирования: порождающие, структурные и поведенческие. Кратко перечислим основные паттерны проектирования для каждого из них.

## Порождающие паттерны

Порождающие паттерны проектирования абстрагируют процесс инстанцирования(создания экземпляра класса). Они помогут сделать систему независимой от способа создания, композиции и представления объектов. Паттерн, порождающий классы, использует наследование, чтобы варьировать инстанцируемый класс, а паттерн, порождающий объекты, делегирует инстанцирование другому объекту.

Для порождающих паттернов актуальны две темы. Во-первых, эти паттерны инкапсулируют знания о конкретных классах, которые применяются в системе. Во-вторых, скрывают детали того, как эти классы создаются и стыкуются. Единственная информация об объектах, известная системе, – это их интерфейсы, определенные с помощью абстрактных классов. Следовательно, порождающие паттерны обеспечивают большую гибкость при решении вопроса о том, что создается, кто это создает, как и когда.

### Простая фабрика(Simple Factory)

<img src="https://avatars.mds.yandex.net/i?id=1ae20289f5fe033378b9b64e413abd21_sr-7042882-images-thumbs&n=13&exp=1" alt="img" style="zoom:67%;" />

В объектно-ориентированном программировании (ООП), <u>фабрика</u> — это объект для создания других объектов. Формально фабрика — это функция или метод, который возвращает объекты изменяющегося прототипа или класса из некоторого вызова метода, который считается «новым».

*Пример из жизни*: Представьте, что вам надо построить дом, и вам нужны двери. Было бы глупо каждый раз, когда вам нужны двери, надевать вашу столярную форму и начинать делать дверь. Вместо этого вы делаете её на фабрике.

*Простыми словами:* Простая фабрика генерирует экземпляр для клиента, не раскрывая никакой логики.



### Фабричный метод(Factory Method)

<u>Фабричный метод</u> — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

*Пример из жизни*: Рассмотрим пример с менеджером по найму. Невозможно одному человеку провести собеседования со всеми кандидатами на все вакансии. В зависимости от вакансии он должен распределить этапы собеседования между разными людьми.

*Простыми словами*: Менеджер предоставляет способ делегирования логики создания экземпляра дочерним классам.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/3ef5c0fe1b52070b4745bab43aba8fba7c43cc91.png" alt="Структура классов паттерна Фабричный метод" style="zoom:80%;" />

1. *Продукт*  определяет общий интерфейс объектов, которые может создать Creator (создатель) и его подклассы.

2. *Конкретные продукты* содержат код различных продуктов. Продукты будут отличаться реализацией, но интерфейс у них будет общий.

3. *Создатель*  объявляет фабричный метод, который должен возвращать новые объекты продуктов. Важно, чтобы тип возвращаемого значения совпадал с общим интерфейсом продуктов.

   

### Абстрактная фабрика(Abstract Factory)

<u>Абстрактная фабрика</u> — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса AbstractFactory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.

*Пример из жизни*. Вернемся к примеру для простой фабрики. В зависимости от ваших нужд вам понадобится деревянная дверь из одного магазина, железная дверь — из другого или пластиковая — из третьего. Кроме того, вам понадобится соответствующий специалист: столяр для деревянной двери, сварщик для железной двери и так далее. Как вы можете заметить, тут есть зависимость между дверьми.

*Простыми словами.* Фабрика фабрик. Фабрика, которая группирует индивидуальные, но связанные/зависимые фабрики без указания их конкретных классов.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/397cc1f3382df325f0dea4933976d900bd5fe8bf.png" alt="Структура классов паттерна Абстрактная фабрика" style="zoom:80%;" />

1. *Абстрактные продукты* объявляют интерфейсы продуктов, которые связаны друг с другом по смыслу, но выполняют разные функции.

2. *Конкретные продукты* – большой набор классов, которые относятся к различным абстрактным продуктам (кресло/столик), но имеют одни и те же вариации (Викторианский/Модерн).

3. *Абстрактная фабрика* объявляет методы создания различных абстрактных продуктов (кресло/столик).

4. *Конкретные фабрики* относятся каждая к своей вариации продуктов (Викторианский/Модерн) и реализуют методы абстрактной фабрики, позволяя создавать все продукты определённой вариации.

5. Несмотря на то, что конкретные фабрики порождают конкретные продукты, сигнатуры их методов должны возвращать соответствующие абстрактные продукты. Это позволит клиентскому коду, использующему фабрику, не привязываться к конкретным классам продуктов. Клиент сможет работать с любыми вариациями продуктов через абстрактные интерфейсы.

   

### Строитель(Builder)

<u>Строитель</u> — порождающий шаблон проектирования, который предоставляет способ создания составного объекта. Предназначен для решения проблемы антипаттерна «Телескопический конструктор»(конструктор с большим количеством аргументов).

*Пример из жизни*: Представьте, что вы пришли в McDonalds и заказали конкретный продукт, например, БигМак, и вам готовят его без лишних вопросов. Это пример простой фабрики. Но есть случаи, когда логика создания может включать в себя больше шагов. Например, вы хотите индивидуальный сэндвич в Subway: у вас есть несколько вариантов того, как он будет сделан. Какой хлеб вы хотите? Какие соусы использовать? Какой сыр? В таких случаях на помощь приходит шаблон «Строитель».

*Простыми словами*: Шаблон позволяет вам создавать различные виды объекта, избегая засорения конструктора. Он полезен, когда может быть несколько видов объекта или когда необходимо множество шагов, связанных с его созданием.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/32ec79d2d278dbec31f1afcb49027ce0b8b05737.png" alt="Структура классов паттерна Строитель" style="zoom:80%;" />

1. *Интерфейс* строителя объявляет шаги конструирования продуктов, общие для всех видов строителей.

2. *Конкретные строители* реализуют строительные шаги, каждый по-своему. Конкретные строители могут производить разнородные объекты, не имеющие общего интерфейса.

3. *Продукт* – создаваемый объект. Продукты, сделанные разными строителями, не обязаны иметь общий интерфейс.

4. *Директор* определяет порядок вызова строительных шагов для производства той или иной конфигурации продуктов.

5. Обычно *Клиент* подаёт в конструктор директора уже готовый объект-строитель, и в дальнейшем данный директор использует только его. Но возможен и другой вариант, когда клиент передаёт строителя через параметр строительного метода директора. В этом случае можно каждый раз применять разных строителей для производства различных представлений объектов.

   

### Прототип(Prototype)

<u>Прототип</u> задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа. Он позволяет уйти от реализации и позволяет следовать принципу «программирование через интерфейсы». В качестве возвращающего типа указывается интерфейс / абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип.

*Пример из жизни*: Помните Долли? Овечка, которая была клонирована. Не будем углубляться, главное — это то, что здесь все вращается вокруг клонирования.

*Простыми словами*: Прототип создает объект, основанный на существующем объекте при помощи клонирования. То есть он позволяет вам создавать копию существующего объекта и модернизировать его согласно вашим нуждам, вместо того, чтобы создавать объект заново.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/0fa3dbbf59cf3fc83991eaeb8b9b5f10f2a29360.png" alt="Вариант Прототипа с общим хранилищем прототипов" style="zoom:80%;" />

1. Хранилище прототипов облегчает доступ к часто используемым прототипам, храня набор предварительно созданных эталонных, готовых к копированию объектов. Простейшее хранилище может быть построено с помощью хеш-таблицы вида *имя-прототипа → прототип*. Но для удобства поиска прототипы можно маркировать и другими критериями, а не только условным именем.

   

### Одиночка(Singleton)

<u>Одиночка</u> — порождающий шаблон проектирования, гарантирующий, что в однопроцессном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.

*Пример из жизни*: В стране одновременно может быть только один президент. Один и тот же президент должен действовать, когда того требуют обстоятельства. Президент здесь является одиночкой.

*Простыми словами*: Обеспечивает тот факт, что создаваемый объект является единственным объектом своего класса.

Вообще шаблон одиночка признан антипаттерном, необходимо избегать его чрезмерного использования. Он необязательно плох и может иметь полезные применения, но использовать его надо с осторожностью, потому что он вводит глобальное состояние в ваше приложение и его изменение в одном месте может повлиять на другие части приложения, что вызовет трудности при отладке. Другой минус — это то, что он делает ваш код связанным.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/9622e14930c37cf85a96a9b58693a0fb8c4f60f3.png" alt="Структура классов паттерна Одиночка" style="zoom:80%;" />

1. *Одиночка* определяет статический метод getInstance, который возвращает единственный экземпляр своего класса. Конструктор одиночки должен быть скрыт от клиентов. Вызов метода getInstance должен стать единственным способом получить объект этого класса.

   

## Структурные паттерны

В структурных паттернах рассматривается вопрос о том, как из классов и объектов образуются более крупные структуры. Структурные паттерны уровня класса используют наследование для составления композиций из интерфейсов и реализаций.

Вместо композиции интерфейсов или реализаций структурные паттерны уровня объекта компонуют объекты для получения новой функциональности. Дополнительная гибкость в этом случае связана с возможностью изменить композицию объектов во время выполнения, что недопустимо для статической композиции классов.



### Адаптер(Adapter)

<u>Адаптер</u> — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.

*Пример из жизни*: Представим, что у вас на карте памяти есть какие-то изображения и вам надо перенести их на ваш компьютер. Чтобы это сделать, вам нужен какой-то адаптер, который совместим с портами вашего компьютера. В этом случае карт-ридер — это адаптер. Другим примером будет блок питания. Вилку с тремя ножками нельзя вставить в розетку с двумя отверстиями. Для того, чтобы она подошла, надо использовать адаптер. Ещё одним примером будет переводчик, переводящий слова одного человека для другого.

*Простыми словами*: Шаблон позволяет обернуть несовместимые объекты в адаптер, чтобы сделать их совместимыми с другим классом.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/002be81419e71046642dd9f1147655ca39413346.png" alt="Структура классов паттерна Адаптер (адаптер классов)" style="zoom:80%;" />

1. *Адаптер классов* не нуждается во вложенном объекте, так как он может одновременно наследовать и часть существующего класса, и часть сервиса.

   

### Мост(Bridge)

<u>Мост</u> — структурный шаблон проектирования, используемый в проектировании программного обеспечения чтобы разделять абстракцию и реализацию так, чтобы они могли изменяться независимо. Шаблон мост использует инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.

*Пример из жизни*: Представим, что у вас есть сайт с разными страницами, и вам надо разрешить пользователям менять их тему. Что вы будете делать? Создавать множественные копии каждой страницы для каждой темы или просто отдельную тему, которую пользователь сможет выбрать сам? Шаблон мост позволяет вам сделать второе.

*Простыми словами:* Шаблон мост — это предпочтение композиции над наследованием. Детали реализации передаются из одной иерархии в другой объект с отдельной иерархией. 

<img src="https://radioprog.ru/uploads/media/articles/0001/06/d69fc2f0b29dc02376da29b3048e98535450fdeb.png" alt="Структура классов паттерна Мост" style="zoom:80%;" />

1. *Абстракция* содержит управляющую логику. Код абстракции делегирует реальную работу связанному объекту реализации.

2. *Реализация* задаёт общий интерфейс для всех реализаций. Все методы, которые здесь описаны, будут доступны из класса абстракции и его подклассов.

3. *Интерфейсы абстракции* и реализации могут как совпадать, так и быть совершенно разными. Но обычно в реализации живут базовые операции, на которых строятся сложные операции абстракции.

4. *Конкретные реализации* содержат платформо-зависимый код.

5. *Расширенные абстракции* содержат различные вариации управляющей логики. Как и родитель, работает с реализациями только через общий интерфейс реализации.

6. *Клиент* работает только с объектами абстракции. Не считая начального связывания абстракции с одной из реализаций, клиентский код не имеет прямого доступа к объектам реализации.

   

### Компоновщик(Composite)

<u>Компоновщик</u> — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково. Паттерн определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым. Паттерн Компоновщик имеет смысл только тогда, когда основная модель вашей программы может быть структурирована в виде дерева.

*Пример из жизни*: Каждая организация скомпонована из сотрудников. У каждого сотрудника есть одинаковые свойства, такие как зарплата, обязанности, отчётность и т.д.

*Простыми словами*: Шаблон компоновщик позволяет клиентам работать с индивидуальными объектами в едином стиле.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/4811ba66b855f62d7aaf8b0ea3aac489236f1f31.png" alt="Структура классов паттерна Компоновщик" style="zoom:80%;" />

1. *Компонент* определяет общий интерфейс для простых и составных компонентов дерева.

2. *Лист* – это простой компонент дерева, не имеющий ответвлений.
   Из-за того, что им некому больше передавать выполнение, классы листьев будут содержать большую часть полезного кода.

3. *Контейнер* (или *композит*) – это составной компонент дерева. Он содержит набор дочерних компонентов, но ничего не знает об их типах. Это могут быть как простые компоненты-листья, так и другие компоненты-контейнеры. Но это не является проблемой, если все дочерние компоненты следуют единому интерфейсу.
   Методы контейнера переадресуют основную работу своим дочерним компонентам, хотя и могут добавлять что-то своё к результату.

4. *Клиент* работает с деревом через общий интерфейс компонентов.
   Благодаря этому, клиенту не важно, что перед ним находится – простой или составной компонент дерева.

   

### Декоратор(Decorator)

<u>Декоратор</u> — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.

*Пример из жизни*: Любая одежда – это аналог Декоратора. Применяя Декоратор, вы не меняете первоначальный класс и не создаёте дочерних классов. Так и с одеждой – надевая свитер, вы не перестаёте быть собой, но получаете новое свойство – защиту от холода. Вы можете пойти дальше и надеть сверху ещё один декоратор – плащ, чтобы защититься и от дождя.

*Простыми словами*: Шаблон декоратор позволяет вам динамически изменять поведение объекта во время работы, оборачивая их в объект класса декоратора.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/bf256c06d92f56a4e82b0a41867611cf09aa70fc.png" alt="Структура классов паттерна Декоратор" style="zoom: 80%;" />

1. *Компонент* задаёт общий интерфейс обёрток и оборачиваемых объектов.

2. *Конкретный компонент* определяет класс оборачиваемых объектов. Он содержит какое-то базовое поведение, которое потом изменяют декораторы.

3. *Базовый декоратор* хранит ссылку на вложенный объект-компонент. Им может быть как конкретный компонент, так и один из конкретных декораторов. Базовый декоратор делегирует все свои операции вложенному объекту. Дополнительное поведение будет жить в конкретных декораторах.

4. *Конкретные декораторы* – это различные вариации декораторов, которые содержат добавочное поведение. Оно выполняется до или после вызова аналогичного поведения обёрнутого объекта.

5. *Клиент* может оборачивать простые компоненты и декораторы в другие декораторы, работая со всеми объектами через общий интерфейс компонентов.

   

### Фасад(Facade)

<u>Фасад</u> — структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.

*Пример из жизни*: Как вы включаете компьютер? Нажимаю на кнопку включения, скажете вы. Это то, во что вы верите, потому что вы используете простой интерфейс, который компьютер предоставляет для доступа снаружи. Внутри же должно произойти гораздо больше вещей. Этот простой интерфейс для сложной подсистемы называется фасадом.

*Простыми словами*: Шаблон фасад предоставляет упрощенный интерфейс для сложной системы.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/c851a6218885f3cbb91cabe63d164cfedaa53b6b.png" alt="Структура классов паттерна Фасад" style="zoom: 80%;" />

1. *Фасад* предоставляет быстрый доступ к определённой функциональности подсистемы. Он «знает», каким классам нужно переадресовать запрос, и какие данные для этого нужны.

2. *Дополнительный фасад* можно ввести, чтобы не «захламлять» единственный фасад разнородной функциональностью. Он может использоваться как клиентом, так и другими фасадами.

3. *Сложная подсистема* состоит из множества разнообразных классов. Для того, чтобы заставить их что-то делать, нужно знать подробности устройства подсистемы, порядок инициализации объектов и так далее.
   Классы подсистемы не знают о существовании фасада и работают друг с другом напрямую.

4. *Клиент* использует фасад вместо прямой работы с объектами сложной подсистемы.

   

### Легковес(Flyweight)

<u>Легковес</u> — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

*Пример из жизни*: Вы когда-нибудь заказывали чай в уличном ларьке? Там зачастую готовят не одну чашку, которую вы заказали, а гораздо большую емкость. Это делается для того, чтобы экономить ресурсы (газ/электричество). Газ/электричество в этом примере и являются легковесами, ресурсы которых делятся (sharing).

*Простыми словами*: Легковес используется для минимизации использования памяти или вычислительной стоимости путем разделения ресурсов с наибольшим количеством похожих объектов.

Для удобства работы с легковесами и контекстами можно создать <u>фабричный метод</u>, принимающий в параметрах всё внутреннее (а иногда и внешнее) состояние желаемого объекта.

Главная польза от этого метода в том, чтобы искать уже созданные легковесы с таким же внутренним состоянием, что и требуемое. Если легковес находится, его можно повторно использовать. Если нет – просто создаём новый. Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику. Его даже можно сделать статическим и поместить в класс легковесов.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/33c1abcb7254c9c5b90cb24f7fe7dbf35594da87.png" alt="Паттерн Легковес (Приспособленец)" style="zoom:80%;" />

1. Вы всегда должны помнить о том, что Легковес применяется в программе, имеющей громадное количество одинаковых объектов. Этих объектов должно быть так много, чтобы они не помещались в доступную оперативную память без ухищрений. Паттерн разделяет данные этих объектов на две части – легковесы и контексты.

2. *Легковес* содержит состояние, которое повторялось во множестве первоначальных объектов. Один и тот же легковес можно использовать в связке со множеством контекстов. Состояние, которое хранится здесь, называется *внутренним*, а то, которое он получает извне – *внешним*.

3. *Контекст* содержит «внешнюю» часть состояния, уникальную для каждого объекта. Контекст связан с одним из объектов-легковесов, хранящих оставшееся состояние.

4. Поведение оригинального объекта чаще всего оставляют в Легковесе, передавая значения контекста через параметры методов. Тем не менее, поведение можно поместить и в контекст, используя легковес как объект данных.

5. *Клиент* вычисляет или хранит контекст, то есть внешнее состояние легковесов. Для клиента легковесы выглядят как шаблонные объекты, которые можно настроить во время использования, передав контекст через параметры.

6. *Фабрика легковесов* управляет созданием и повторным использованием легковесов. Фабрика получает запросы, в которых указано желаемое состояние легковеса. Если легковес с таким состоянием уже создан, фабрика сразу его возвращает, а если нет – создаёт новый объект.

   

### Заместитель(Proxy)

<u>Заместитель</u> — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

*Пример из жизни*: Вы когда-нибудь использовали карту доступа, чтобы пройти через дверь? Есть несколько способов открыть дверь: например, она может быть открыта при помощи карты доступа или нажатия кнопки, которая обходит защиту. Основная функциональность двери — это открытие, но заместитель, добавленный поверх этого, добавляет функциональность.

*Простыми словами*: Используя шаблон заместитель, класс отображает функциональность другого класса.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/7397ffdca8eba7747ef30fdb4954fc234009b569.png" alt="Структура классов паттерна Заместитель" style="zoom:80%;" />

1. *Интерфейс* сервиса определяет общий интерфейс для сервиса и заместителя. Благодаря этому, объект заместителя можно использовать там, где ожидается объект сервиса.

2. *Сервис* содержит полезную бизнес-логику.

3. *Заместитель* хранит ссылку на объект сервиса. После того как заместитель заканчивает свою работу (например, инициализацию, логирование, защиту или другое), он передаёт вызовы вложенному сервису.
   Заместитель может сам отвечать за создание и удаление объекта сервиса.

4. *Клиент* работает с объектами через интерфейс сервиса. Благодаря этому, его можно «одурачить», подменив объект сервиса объектом заместителя.

   

## Поведенческие паттерны

Поведенческие шаблоны (behavioral patterns) — шаблоны проектирования, определяющие алгоритмы и способы реализации взаимодействия различных объектов и классов. Проще говоря, поведенческие паттерны связаны с распределением обязанностей между объектами и описывают структуру и шаблоны для передачи сообщений/связи между компонентами. 



### Цепочка обязанностей (Chain of Responsibility)

<u>Цепочка обязанностей</u> — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

*Пример из жизни*: например, у вас есть три платежных метода (A, B и C), настроенных на вашем банковском счёте. На каждом лежит разное количество денег. На A есть 100 долларов, на B есть 300 долларов и на C — 1000 долларов. Предпочтение отдается в следующем порядке: A, B и C. Вы пытаетесь заказать что-то, что стоит 210 долларов. Используя цепочку обязанностей, первым на возможность оплаты будет проверен метод А, и в случае успеха пройдет оплата и цепь разорвется. Если нет, то запрос перейдет к методу B для аналогичной проверки. Здесь A, B и C — это звенья цепи, а все явление — цепочка обязанностей.

*Простыми словами*: цепочка обязанностей помогает строить цепочки объектов. Запрос входит с одного конца и проходит через каждый объект, пока не найдет подходящий обработчик.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/a2e615aa1e7839693bf4f9f4c26a19c16364b087.png" alt="Структура классов паттерна Цепочка обязанностей" style="zoom:80%;" />

1. <u>Обработчик</u> определяет общий для всех конкретных обработчиков интерфейс. Обычно достаточно описать единственный метод обработки запросов, но иногда здесь может быть объявлен и метод выставления следующего обработчика.

2. <u>Базовый обработчик</u> – опциональный класс, который позволяет избавиться от дублирования одного и того же кода во всех конкретных обработчиках. Обычно этот класс имеет поле для хранения ссылки на следующий обработчик в цепочке. Клиент связывает обработчики в цепь, подавая ссылку на следующий обработчик через конструктор или сеттер поля. Также здесь можно реализовать базовый метод обработки, который бы просто перенаправлял запрос следующему обработчику, проверив его наличие.

3. <u>Конкретные обработчики</u> содержат код обработки запросов. При получении запроса каждый обработчик решает, может ли он обработать запрос, а также стоит ли передать его следующему объекту. В большинстве случаев обработчики могут работать сами по себе и быть неизменяемыми, получив все нужные детали через параметры конструктора.

4. <u>Клиент</u> может либо сформировать цепочку обработчиков единожды, либо перестраивать её динамически, в зависимости от логики программы. Клиент может отправлять запросы любому из объектов цепочки, не обязательно первому из них.

   

### Команда(Command)

<u>Команда</u> – это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

<u>Пример из жизни:</u> Типичный пример: вы заказываете еду в ресторане. Вы (т.е. Client) просите официанта (например, Invoker) принести еду (то есть Command), а официант просто переправляет запрос шеф-повару (то есть Receiver), который знает, что и как готовить. Другим примером может быть то, что вы (Client) включаете (Command) телевизор (Receiver) с помощью пульта дистанционного управления (Invoker).

<u>Простыми словами:</u> Позволяет вам инкапсулировать действия в объекты. Основная идея, стоящая за шаблоном — это предоставление средств, для разделения клиента и получателя.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/1f37e3b0934077662af3adf4b8ea3e4cc58e4127.png" alt="Структура классов паттерна Команда" style="zoom:80%;" />

1. <u>Отправитель</u> хранит ссылку на объект команды и обращается к нему, когда нужно выполнить какое-то действие. Отправитель работает с командами только через их общий интерфейс. Он не знает, какую конкретно команду использует, так как получает готовый объект команды от клиента.

2. <u>Команда</u> описывает общий для всех конкретных команд интерфейс. Обычно здесь описан всего один метод для запуска команды.

3. <u>Конкретные команды</u> реализуют различные запросы, следуя общему интерфейсу команд. Обычно команда не делает всю работу самостоятельно, а лишь передаёт вызов получателю, которым является один из объектов бизнес-логики. Параметры, с которыми команда обращается к получателю, следует хранить в виде полей. В большинстве случаев объекты команд можно сделать неизменяемыми, передавая в них все необходимые параметры только через конструктор.

4. <u>Получатель</u> содержит бизнес-логику программы. В этой роли может выступать практически любой объект. Обычно команды перенаправляют вызовы получателям. Но иногда, чтобы упростить программу, вы можете избавиться от получателей, «слив» их код в классы команд.

5. <u>Клиент</u> создаёт объекты конкретных команд, передавая в них все необходимые параметры, среди которых могут быть и ссылки на объекты получателей. После этого клиент связывает объекты отправителей с созданными командами.

   

### Итератор (Iterator)

<u>Итератор</u> - это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

*Пример из жизни*: Старый радионабор будет хорошим предметом итератора, где пользователь может начать искать сигнал на каком-то канале и затем использовать кнопки переключения на следующий и предыдущий канал для перехода между соответствующими каналами. Или используем пример телевизора, где вы можете нажимать кнопки следующего или предыдущего канала для перехода через последовательные каналы, или, иными словами, они предоставляют интерфейс для итерирования между соответствующими каналами, песнями или радиостанциями.

*Простыми словами*: Представляет способ доступа к элементам объекта без показа базового представления.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/b81c1b23d5c9bf02f19f94e8ec0dc1c10530d3d8.png" alt="Структура классов паттерна Итератор" style="zoom:80%;" />

1. *Итератор* описывает интерфейс для доступа и обхода элементов коллекции.

2. *Конкретный итератор* реализует алгоритм обхода какой-то конкретной коллекции. Объект итератора должен сам отслеживать текущую позицию при обходе коллекции, чтобы отдельные итераторы могли обходить одну и ту же коллекцию независимо.

3. *Коллекция* описывает интерфейс получения итератора из коллекции. Как мы уже говорили, коллекции не всегда являются списком. Это может быть и база данных, и удалённое API, и даже дерево Компоновщика. Поэтому сама коллекция может создавать итераторы, так как она знает, какие именно итераторы способны с ней работать.

4. *Конкретная коллекция* возвращает новый экземпляр определённого конкретного итератора, связав его с текущим объектом коллекции. Обратите внимание, что сигнатура метода возвращает интерфейс итератора. Это позволяет клиенту не зависеть от конкретных классов итераторов.

5. *Клиент* работает со всеми объектами через интерфейсы коллекции и итератора. Так клиентский код не зависит от конкретных классов, что позволяет применять различные итераторы, не изменяя существующий код программы. В общем случае клиенты не создают объекты итераторов, а получают их из коллекций. Тем не менее, если клиенту требуется специальный итератор, он всегда может создать его самостоятельно.

   

### Посредник (Mediator)

<u>Посредник</u> - это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.

*Пример из жизни*: Общим примером будет, когда вы говорите с кем-то по мобильнику, то между вами и собеседником находится мобильный оператор. То есть сигнал передаётся через него, а не напрямую. В данном примере оператор — посредник.

*Простыми словами:* Шаблон посредник подразумевает добавление стороннего объекта (посредника) для управления взаимодействием между двумя объектами (коллегами). Шаблон помогает уменьшить связанность (coupling) классов, общающихся друг с другом, ведь теперь они не должны знать о реализациях своих собеседников.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/bdf6292872692c9f8139e77a3d415baf3ef645d6.png" alt="Структура классов паттерна Посредник" style="zoom:80%;" />

1. *Компоненты* – это разнородные объекты, содержащие бизнес-логику программы. Каждый компонент хранит ссылку на объект посредника, но работает с ним только через абстрактный интерфейс посредников. Благодаря этому, компоненты можно повторно использовать в другой программе, связав их с посредником другого типа.

2. *Посредник* определяет интерфейс для обмена информацией с компонентами. Обычно хватает одного метода, чтобы оповещать посредника о событиях, произошедших в компонентах. В параметрах этого метода можно передавать детали события: ссылку на компонент, в котором оно произошло, и любые другие данные.

3. *Конкретный посредник* содержит код взаимодействия нескольких компонентов между собой. Зачастую этот объект не только хранит ссылки на все свои компоненты, но и сам их создаёт, управляя дальнейшим жизненным циклом.

4. Компоненты не должны общаться друг с другом напрямую. Если в компоненте происходит важное событие, он должен оповестить своего посредника, а тот сам решит – касается ли событие других компонентов, и стоит ли их оповещать. При этом компонент-отправитель не знает кто обработает его запрос, а компонент-получатель не знает кто его прислал.

   

### Снимок (Memento)

<u>Снимок</u> — поведенческий шаблон проектирования, позволяющий, не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в этом состоянии.

*Пример из жизни*: В качестве примера можно привести калькулятор (создатель), у которого любая последняя выполненная операция сохраняется в памяти (Снимок), чтобы вы могли снова вызвать её с помощью каких-то кнопок (опекун).

*Простыми словами*: Шаблон Снимок фиксирует и хранит текущее состояние объекта, чтобы оно легко восстанавливалось.

Классическая реализация паттерна полагается на механизм вложенных классов, который доступен лишь в некоторых языках программирования (C++, C#, Java).

<img src="https://radioprog.ru/uploads/media/articles/0001/06/201348e0f6a085a24a45d131ac68082bf073e7ff.png" alt="Структура классов паттерна Снимок (Хранитель)" style="zoom:80%;" />

1. <u>Создатель</u> может производить снимки своего состояния, а также воспроизводить прошлое состояние, если подать в него готовый снимок.

2. <u>Снимок</u> – это простой объект данных, содержащий состояние создателя. Надёжнее всего сделать объекты снимков неизменяемыми, передавая в них состояние только через конструктор.

3. <u>Опекун</u> должен знать, когда делать снимок создателя, и когда нужно, восстанавливать его. Опекун может хранить историю прошлых состояний создателя в виде стека из снимков. Когда понадобится отменить выполненную операцию, он возьмёт «верхний» снимок из стека и передаст его создателю для восстановления.

4. В данной реализации снимок – это внутренний класс по отношению к классу создателя. Именно поэтому он имеет полный доступ к полям и методам создателя, даже приватным. С другой стороны, опекун не имеет доступа ни к состоянию, ни к методам снимков и может всего лишь хранить ссылки на эти объекты.

   

### Наблюдатель (Observer)

<u>Наблюдатель</u> — поведенческий шаблон проектирования, также известен как «подчинённые» (Dependents). Создает механизм у класса, который позволяет получать экземпляру объекта этого класса оповещения от других объектов об изменении их состояния, тем самым наблюдая за ними.

*Пример из жизни*: Хороший пример: люди, ищущие работу, подписываются на публикации на сайтах вакансий и получают уведомления, когда появляются вакансии подходящие по параметрам.

*Простыми словами*: Шаблон определяет зависимость между объектами, чтобы при изменении состояния одного из них зависимые от него узнавали об этом.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/cedd04a42708b8df01e79424ed4684665c9d66c3.png" alt="Структура классов паттерна Наблюдатель" style="zoom:80%;" />

1. <u>Издатель</u> владеет внутренним состоянием, изменение которого интересно отслеживать подписчикам. Издатель содержит механизм подписки: список подписчиков и методы подписки/отписки.

2. Когда внутреннее состояние издателя меняется, он оповещает своих подписчиков. Для этого издатель проходит по списку подписчиков и вызывает их метод оповещения, заданный в общем интерфейсе подписчиков.

3. <u>Подписчик</u> определяет интерфейс, которым пользуется издатель для отправки оповещения. В большинстве случаев для этого достаточно единственного метода.

4. <u>Конкретные подписчики</u> выполняют что-то в ответ на оповещение, пришедшее от издателя. Эти классы должны следовать общему интерфейсу подписчиков, чтобы издатель не зависел от конкретных классов подписчиков.

5. По приходу оповещения подписчику нужно получить обновлённое состояние издателя. Издатель может передать это состояние через параметры метода оповещения. Более гибкий вариант – передавать через параметры весь объект издателя, чтобы подписчик мог сам получить требуемые данные. Как вариант, подписчик может постоянно хранить ссылку на объект издателя, переданный ему в конструкторе.

6. <u>Клиент</u> создаёт объекты издателей и подписчиков, а затем регистрирует подписчиков на обновления в издателях.

   

### Посетитель (Visitor)

<u>Посетитель</u> — поведенческий шаблон проектирования, описывающий операцию, которая выполняется над объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.

*Пример из жизни*: Туристы собрались в Дубай. Сначала им нужен способ попасть туда (виза). После прибытия они будут посещать любую часть города, не спрашивая разрешения ходить где вздумается. Просто скажите им о каком-нибудь месте — и туристы могут там побывать. Шаблон посетитель помогает добавлять места для посещения.

*Простыми словами*: Шаблон посетитель позволяет добавлять будущие операции для объектов без их модифицирования.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/add4bbfd902872fb3e54b36b13089a76e3b81e84.png" alt="Структура классов паттерна Посетитель" style="zoom:80%;" />

1. *Посетитель* описывает общий интерфейс для всех типов посетителей. Он объявляет набор методов, отличающихся типом входящего параметра, которые нужны для запуска операции для всех типов конкретных элементов. В языках, поддерживающих перегрузку методов, эти методы могут иметь одинаковые имена, но типы их параметров должны отличаться.

2. *Конкретные посетители* реализуют какое-то особенное поведение для всех типов элементов, которые можно подать через методы интерфейса посетителя.

3. *Элемент* описывает метод *принятия* посетителя. Этот метод должен иметь единственный параметр, объявленный с типом интерфейса посетителя.

4. *Конкретные элементы* реализуют методы *принятия* посетителя. Цель этого метода – вызвать тот метод посещения, который соответствует типу этого элемента. Так посетитель узнает, с каким именно элементом он работает.

5. *Клиентом* зачастую выступает коллекция или сложный составной объект, например, дерево Компоновщика. Зачастую клиент не привязан к конкретным классам элементов, работая с ними через общий интерфейс элементов.

   

### Стратегия (Strategy)

<u>Стратегия</u> — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

*Пример из жизни*: Возьмём пример с пузырьковой сортировкой. Мы её реализовали, но с ростом объёмов данных сортировка работа стала выполняться очень медленно. Тогда мы сделали быструю сортировку. Алгоритм работает быстрее на больших объёмах, но на маленьких он очень медленный. Тогда мы реализовали стратегию, при которой для маленьких объёмов данных используется пузырьковая сортировка, а для больших объёмов — быстрая.

*Простыми словами*: Шаблон стратегия позволяет переключаться между алгоритмами или стратегиями в зависимости от ситуации.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/269e58713229ff1142175c049acc355e52eb1901.png" alt="Структура классов паттерна Стратегия" style="zoom:80%;" />

1. *Контекст* хранит ссылку на объект конкретной стратегии, работая с ним через общий интерфейс стратегий.

2. *Стратегия* определяет интерфейс, общий для всех вариаций алгоритма. Контекст использует этот интерфейс для вызова алгоритма. Для контекста неважно, какая именно вариация алгоритма будет выбрана, так как все они имеют одинаковый интерфейс.

3. *Конкретные стратегии* реализуют различные вариации алгоритма.

4. Во время выполнения программы контекст получает вызовы от клиента и делегирует их объекту конкретной стратегии.

5. *Клиент* должен создать объект конкретной стратегии и передать его в конструктор контекста. Кроме этого, клиент должен иметь возможность заменить стратегию на лету, используя сеттер. Благодаря этому, контекст не будет знать о том, какая именно стратегия сейчас выбрана.

   

### Состояние (State)

<u>Состояние</u> — поведенческий шаблон проектирования. Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.

*Пример из жизни*: Допустим, в графическом редакторе вы выбрали кисть. Она меняет своё поведение в зависимости от настройки цвета, т. е. рисует линию выбранного цвета.

*Простыми словами*: Шаблон позволяет менять поведение класса при изменении состояния.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/27123dfca4e4a5b759cc758c608abb93af3a119b.png" alt="Структура классов паттерна Состояние" style="zoom:80%;" />

1. *Контекст* хранит ссылку на объект состояния и делегирует ему часть работы, зависящей от состояний. Контекст работает с этим объектом через общий интерфейс состояний. Контекст должен иметь метод для присваивания ему нового объекта-состояния.

2. *Состояние* описывает общий интерфейс для всех конкретных состояний.

3. *Конкретные состояния* реализуют поведения, связанные с определённым состоянием контекста. Иногда приходится создавать целые иерархии классов состояний, чтобы обобщить дублирующий код. Состояние может иметь обратную ссылку на объект контекста. Через неё не только удобно получать из контекста нужную информацию, но и осуществлять смену его состояния.

4. И контекст, и объекты конкретных состояний могут решать, когда и какое следующее состояние будет выбрано. Чтобы переключить состояние, нужно подать другой объект-состояние в контекст.

   

### Шаблонный метод (Template Method)

<u>Шаблонный метод</u> — поведенческий шаблон проектирования, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.

*Пример из жизни*: Допустим, вы собрались строить дома. Этапы будут такими:

1. Подготовка фундамента.

2. Возведение стен.
3. Настил крыши.
4. Настил перекрытий.
5. Порядок этапов никогда не меняется. Вы не настелите крышу до возведения стен и т. д. Но каждый этап модифицируется: стены, например, можно возвести из дерева, кирпича или газобетона.

*Простыми словами*: Шаблонный метод определяет каркас выполнения определённого алгоритма, но реализацию самих этапов делегирует дочерним классам.

<img src="https://radioprog.ru/uploads/media/articles/0001/06/09f5d962978362af214f362e3b6cf74bd1bdaefd.png" alt="Структура классов паттерна Шаблонный Метод" style="zoom:80%;" />

1. *Абстрактный класс* определяет шаги алгоритма и содержит шаблонный метод, состоящий из вызовов этих шагов. Шаги могут быть как абстрактными, так и содержать реализацию по умолчанию.

2. *Конкретный класс* переопределяет некоторые (или все) шаги алгоритма. Конкретные классы не переопределяют сам шаблонный метод.

