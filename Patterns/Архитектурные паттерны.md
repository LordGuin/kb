# Архитектурные паттерны

------

**Архитектурные паттерны** представляют собой наивысший слой детализации в проекте. Они определяет архитектуру приложения, задают его логику (на какие компоненты/модули будет делиться приложение и каким образом они взаимодействуют) и помогают разработчику понять, как устроен продукт внутри. Выбор архитектурных паттернов происходит на этапе создания продукта.

Архитектурные паттерны также можно классифицировать:

- <ins>Вызов-возврат</ins>. Порядок выполнения действий четко определен, отдельные компоненты не могут выполнять полезную работу, не получая обращения от других. Примеры:

  1. Многоуровневая архитектура
  2. Архитектуры клиент-сервер

- <ins>Конвейер обработки данных</ins>. Система выдает четко определенные выходные данные в результате обработки четко определенных входных данных, при этом процесс обработки не зависит от времени, применяется многократно, одинаково к любым данным на входе. Обработка организуется в виде набора (не обязательно последовательности) отдельных компонентов-обработчиков, передающих свои результаты на вход другим обработчикам или на выход всей системы. Важными свойствами являются четко определенная структура данных и возможность интеграции с другими системами. Пример:

  1. Каналы и фильтры

- <ins>Интерактивные системы</ins>. Необходимость достаточно быстро реагировать на действия пользователя, изменчивость пользовательского интерфейса. Пример:

  1. Модель-представление-контроллер

  

Рассмотрим некоторые из перечисленных архитектур

## Многослойная архитектура

![img](https://miro.medium.com/max/188/0*UMS8Cjp3Jd2WvQAg)

### Принцип

Этот подход работает по принципу разделения ответственностей. ПО разделено на слои, лежащие друг на друге, и каждый из них выполняет определенную обязанность.  *Слой*— это механизм логического структурирования компонентов, из которых состоит программное решение.

Всю функциональность приложения, так или иначе, можно разделить на группы, в зависимости от того, какая задача выполняется этой функциональностью, что приложение посредством неё делает (общается с пользователем или осуществляет валидацию данных, или манипулирует данными из базы, или описывает сущности, или описывает логику и т.д.). Задача слоя определяет его роль и ответственность.

Если стараться правильно разрабатывать архитектуру, то нужно определять каждый слой так, чтобы его можно было легко заменить на аналогичный или использовать повторно в другом приложении. Это достигается посредством так называемого слабого связывания (low cohesion). А слабое связывание – это результат грамотного использования таких принципов объектно-ориентированного программирования, как абстракция и полиморфизм.

Чаще всего используется следующие слои:

- <ins>Слой представления</ins> (Presentation Layer) содержит пользовательский интерфейс и отвечает за обеспечение хорошего пользовательского опыта.
- <ins>Слой бизнес-логики</ins> (Business Logic Layer), как следует из названия, содержит бизнес-логику приложения. Он отделяет UI/UX от вычислений, связанных с бизнесом. Это позволяет с легкостью изменять логику в зависимости от постоянно меняющихся бизнес-требований, никак не влияя на другие слои.
- <ins>Слой передачи данных</ins> (Data Link Layer) отвечает за взаимодействие с постоянными хранилищами, такими как базы данных, и прочую обработку информации, которая не связана с бизнесом.

Данные и элементы управления проходят через каждый слой в дизайне и передаются от одного к другому. Эта система также повышает уровень абстракции и в некоторой степени даже стабильность ПО.

![img](https://miro.medium.com/max/700/0*8K9M4IcWg2vNRGQc.png)

### Плюсы

- Более простая реализация по сравнению с другими подходами.
- Предлагает абстракцию благодаря разделению ответственностей между слоями.
- Изолирование защищает одни слои от изменений других.
- Повышает управляемость программного обеспечения за счет слабой связанности.

### Минусы

- Не предлагает большой масштабируемости.
- ПО, созданное с таким подходом, будет иметь монолитную структуру, усложняющую внесение модификаций.
- Данные должны проходить по каждому слою, даже если нет необходимости передавать их с определенных слоев.

### Где использовать
- Общие десктопные приложения.
- Веб-приложения e-commerce.


## Клиент-серверная архитектура

![img](https://miro.medium.com/max/284/0*JB9pLu-_DAtR9hQC)

### Принцип

Данный шаблон состоит из двух частей: *сервера* и множества *клиентов*. Серверный компонент предоставляет службы клиентским компонентам. Клиенты запрашивают услуги у сервера, а он, в свою очередь, оказывает эти самые услуги клиентам. Более того, сервер продолжает «подслушивать» клиентские запросы.

Характеристика *клиент-сервер* описывает отношения взаимодействующих программ в приложении. Серверный компонент предоставляет функцию или услугу одному или нескольким клиентам, которые инициируют запросы на такие услуги. Серверы классифицируются по предоставляемым ими услугам. Например, веб-сервер обслуживает веб-страницы, а файловый сервер обслуживает компьютерные файлы. Общий ресурс может быть любой из программного обеспечения и электронных компонентов компьютера — сервера, от программ и данных в процессорах и запоминающих устройств. Совместное использование ресурсов сервера представляет собой *услугу*.

Является ли компьютер клиентом, сервером или и тем, и другим, определяется характером приложения, которому требуются сервисные функции. Например, на одном компьютере могут одновременно работать веб-серверы и программное обеспечение файлового сервера, чтобы обслуживать разные данные для клиентов, отправляющих различные типы запросов. Клиентское программное обеспечение также может взаимодействовать с серверным программным обеспечением на том же компьютере. Связь между серверами, например, для синхронизации данных, иногда называется *межсерверной*.

### Плюсы

- Подходит для моделирования набор служб, которые смогут запрашивать клиенты.

### Минусы

- Запросы обычно выполняются в отдельных потоках на сервере.
- Взаимодействие между процессами повышает ресурсозатратность, т.к. разные клиенты имеют разное представление.

От клиент-серверной архитектуры образуются многоуровневые архитектуры в которых функции сервера разделяются *уровни* абстракции.

### Где использовать
- Онлайн приложения (электронная почта, совместный доступ к документам, банковские услуги)


## Каналы и фильтры(Pipes and Filtrers)

<img src="https://habrastorage.org/getpro/habr/upload_files/5c3/e85/c06/5c3e85c0676997f4157540972de05791.png" alt="Подход «каналы и фильтры»" style="zoom:80%;" />

### Принцип

Этот вид архитектуры подходит в том случае, если процесс работы приложения распадается на несколько шагов, которые могут выполнятся отдельными обработчиками. Основными компонентами являются «фильтр» (filter) и «канал» (pipe). Иногда дополнительно выделяют «источник данных» (data source) и «потребитель данных» (data sink).

Каждый поток обработки данных – это серия чередующихся фильтров и каналов, начинающаяся источником данных и заканчивающаяся их потребителем. Каналы обеспечивают передачу данных и синхронизацию. Фильтр же принимает на вход данные и обрабатывает их, трансформируя в некое иное представление, а затем передает дальше.

### Плюсы

- Фильтры можно легко заменять, использовать повторно, переставлять местами, что дает возможность реализовывать множество функций на основе ограниченного набора компонентов
- Активные фильтры могут работать параллельно, что приводит к значительному повышению производительности на многопроцессорных системах

### Минусы

- Фильтры зачастую тратят больше времени на преобразование входных данных, чем на их обработку
- Не лучший выбор для интерактивных систем, поскольку такая архитектура ориентирована на преобразование данных.

### Где использовать
- Компиляторы. Последовательные фильтры выполняют лексический, синтаксический, семантический анализ и создание кода
- Рабочие процессы в биоинформатике

  
## Модель-Представление-Контроллер(Model-View-Controller)

![img](https://miro.medium.com/max/600/0*AqPSXng3k8KlwHYN)

### Принцип

Этот шаблон также известен как MVC-шаблон. Основное назначение MVC - сложный интерфейс. В MVC приложение разделяется на 3 части:

1. модель — содержит ключевые данные и функционал;

2. представление — показывает информацию пользователю (можно задавать более одного представления);

3. контроллер — занимается обработкой данных от пользователя.

Это делается с целью разграничения внутреннего представления информации от способов ее представления и принятия от пользователя. Данная схема изолирует компоненты и позволяет эффективно реализовать повторное использование кода.

### Плюсы

- Упрощает создание различных представлений одной и той же модели; их можно включить или отключить на этапе выполнения.

### Минусы

- Возрастает сложность алгоритма. Может привести ко многим ненужным корректировкам действий пользователей.
- Для простых пользовательских интерфейсов такая сложность может быть чрезмерной.


### Где использовать
- ПО с фокусом на интерфейс
- Архитектура WWW-приложений, написанных на основных языках программирования.
- Веб-фреймворки (например, Django и Rails)

##Литература
1. [Краткий обзор некоторых архитектурных паттернов](https://medium.com/nuances-of-programming/краткий-обзор-10-популярных-архитектурных-шаблонов-приложений-81647be5c46f)
2. [Классификация архитектурных паттернов](https://studfile.net/preview/993777/page:24/)
