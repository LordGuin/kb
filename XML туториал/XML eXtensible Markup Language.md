# XML eXtensible Markup Language - расширяемый язык разметки
----------------------------------------------------------------
Если вы тестируете API, то должны знать про два основных формата передачи данных:

- XML — используется в SOAP *(всегда)* и REST-запросах *(реже)*;
- JSON — используется в REST-запросах.

Подробнее про Soap можно почитать [здесь](https://habr.com/ru/post/483202/)
Подробнее про REST можно почитать [здесь](https://github.com/nnstu-appmath/kb/blob/master/REST/rest_documentation.md)

Сегодня я расскажу вам про XML.
XML, в переводе с англ *eXtensible Markup Language* — расширяемый язык разметки. Используется для хранения и передачи данных. Так что увидеть его можно не только в API, но и в коде.

Этот формат рекомендован Консорциумом Всемирной паутины (W3C), поэтому он часто используется для передачи данных по API. В SOAP API это вообще единственно возможный формат входных и выходных данных!

Cвое название расширяемый язык разметки XML (Extensible Markup Language) получил по той причине, что в нем нет фиксированного формата, как в HTML. В то время как язык HTML ограничивается набором твердо закрепленных тегов, пользователи XML могут создавать свои собственные тэги, которые бы отвечали тематике документа. Таким образом, XML - это метаязык. Этот язык используется в качестве средства для описания грамматики других языков и контроля за правильностью составления документов.

## Сходство с HTML

• В XML существуют открывающие, закрывающие и пустые тэги.
• Теги в документе могут быть вложены друг в друга.
• Теги начала и конца элемента являются основными используемыми в XML разметками. Так же как и в HTML тэги могут иметь атрибуты, причем количество атрибутов зависит от фантазии автора.
• Документы XML могут содержать ссылки на другие объекты.

![XML vs. HTML: What are the Differences? - Geekflare](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.001.png)

## Основные отличия от HTML

- Большое внимание уделяется контролю документа.
- Проверка действительности документа предполагает выполнение следующих действий: 
1. Синтаксическая проверка;
1. Проверка валидности документа.

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.002.png)

## Части XML документа

- Процессинговые
  инструкции
- Элементы
- Корневой элемент
- Дочерние элементы
- Атрибуты
- Комментарии

![XML - 维基百科，自由的百科全书](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.003.png)

## Как устроен XML? 
-------------------------------------

## Теги

В XML каждый элемент должен быть заключен в теги. Тег — это некий текст, обернутый в угловые скобки:
```sh
<tag>
```
Текст внутри угловых скобок — название тега.
Тега всегда два:

- Открывающий — текст внутри угловых скобок
```sh
<tag>
```
- Закрывающий — тот же текст (это важно!), но добавляется символ «/»
```sh
</tag>
```
![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.004.png)

## Корневой элемент

В любом XML-документе есть корневой элемент. Это тег, с которого документ начинается, и которым заканчивается. В случае REST API документ — это запрос, который отправляет система. Или ответ, который она получает.

Чтобы обозначить этот запрос, нам нужен корневой элемент. В подсказках корневой элемент — «req».

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.005.png)

## Значение элемента


Значение элемента хранится между открывающим и закрывающим тегами. Это может быть число, строка, или даже вложенные теги!

Вот у нас есть тег «query». Он обозначает запрос, который мы отправляем в подсказки.

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.006.png)

Внутри — значение запроса.

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.007.png)

Это как если бы мы вбили строку «Виктор Иван» в GUI (графическом интерфейсе пользователя):

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.008.png)

Пользователю лишняя обвязка не нужна, ему нужна красивая формочка. А вот системе надо как-то передать, что «пользователь ввел именно это». Как показать ей, где начинается и заканчивается переданное значение? Для этого и используются теги.

Система видит тег «query» и понимает, что внутри него «строка, по которой нужно вернуть подсказки».

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.009.png)

Параметр *count = 7* обозначает, сколько подсказок вернуть в ответе. Если тыкать подсказки на [демо-форме Дадаты](https://dadata.ru/suggestions/#name), нам вернется 7 подсказок. Это потому, что туда вшито как раз значение *count = 7*. А вот если обратиться к [документации метода](https://confluence.hflabs.ru/pages/viewpage.action?pageId=204669115), count можно выбрать от 1 до 20.

Откройте консоль разработчика через *f12*, вкладку *Network*, и посмотрите, какой запрос отправляется на сервер. Там будет значение *count = 7*.

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.010.png)

## Атрибуты элемента

У элемента могут быть атрибуты — один или несколько. Их мы указываем внутри отрывающегося тега после названия тега через пробел в виде
```sh
название\_атрибута = «значение атрибута»
```

Например:
```sh
<query attr1=“value 1”>Виктор Иван</query>
<query attr1=“value 1” attr2=“value 2”>Виктор Иван</query>
```

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.011.png)

Зачем это нужно? Из атрибутов принимающая API-запрос система понимает, что такое ей вообще пришло.
Например, мы делаем поиск по системе, ищем клиентов с именем Олег. Отправляем простой запрос:
```sh
<query>Олег</query>
```

А в ответ получаем целую пачку Олегов! С разными датами рождения, номерами телефонов и другими данными. Допустим, что один из результатов поиска выглядит так:
```sh
<party type="PHYSICAL" sourceSystem="AL" rawId="2">
`    `<field name=“name">Олег </field>
`    `<field name="birthdate">02.01.1980</field>
`    `<attribute type="PHONE" rawId="AL.2.PH.1">
`        `<field name="type">MOBILE</field>
`        `<field name="number">+7 916 1234567</field>
`    `</attribute>
</party>
```

Давайте разберем эту запись. У нас есть основной элемент party.

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.012.png)

У него есть 3 атрибута:

- type = «PHYSICAL» — тип возвращаемых данных. Нужен, если система умеет работать с разными типами: ФЛ, ЮЛ, ИП. Тогда благодаря этому атрибуту мы понимаем, с чем именно имеем дело и какие поля у нас будут внутри. А они будут отличаться! У физика это может быть ФИО, дата рождения ИНН, а у юр лица — название компании, ОГРН и КПП
- sourceSystem = «AL» — исходная система. Возможно, нас интересуют только физ лица из одной системы, будем делать отсев по этому атрибуту.
- rawId = «2» — идентификатор в исходной системе. Он нужен, если мы шлем запрос на обновление клиента, а не на поиск. Как понять, кого обновлять? По связке sourceSystem + rawId!


![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.013.png)

Внутри party есть элементы field.

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.014.png)

У элементов field есть атрибут name. Значение атрибута — название поля: имя, дата рождения, тип или номер телефона. Так мы понимаем, что скрывается под конкретным field.

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.015.png)

Это удобно с точки зрения поддержки, когда у вас коробочный продукт и 10+ заказчиков. У каждого заказчика будет свой набор полей: у кого-то в системе есть ИНН, у кого-то нету, одному важна дата рождения, другому нет, и т.д.

Но, несмотря на разницу моделей, у всех заказчиков будет одна XSD-схема(подробнее про XSD-схему можно прочтать [здесь](https://habr.com/ru/post/90696/)) (которая описывает запрос и ответ):

— есть элемент party;
— у него есть элементы field;
— у каждого элемента field есть атрибут name, в котором хранится название поля.

А вот конкретные названия полей уже можно не описывать в XSD. Их уже «смотрите в ТЗ». Конечно, когда заказчик один или вы делаете ПО для себя или «вообще для всех», удобнее использовать именованные поля — то есть «говорящие» теги. Какие плюшки у этого подхода:

— При чтении XSD сразу видны реальные поля. ТЗ может устареть, а код будет актуален.
— Запрос легко дернуть вручную в SOAP Ui — он сразу создаст все нужные поля, нужно только значениями заполнить. Это удобно тестировщику + заказчик иногда так тестирует, ему тоже хорошо.

В общем, любой подход имеет право на существование. Надо смотреть по проекту, что будет удобнее именно вам. У меня в примере неговорящие названия элементов — все как один будут field. А вот по атрибутам уже можно понять, что это такое.

Помимо элементов field в party есть элемент attribute. Не путайте xml-нотацию и бизнес-прочтение:

- с точки зрения бизнеса это атрибут физ лица, отсюда и название элемента — *attribute*.
- с точки зрения xml — это элемент (не атрибут!), просто его назвали *attribute*. XML все равно (почти), как вы будете называть элементы, так что это допустимо.


![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.016.png)

У элемента attribute есть атрибуты:

- type = «PHONE» — тип атрибута. Они ведь разные могут быть: телефон, адрес, емейл...
- rawId = «AL.2.PH.1» — идентификатор в исходной системе. Он нужен для обновления. Ведь у одного клиента может быть несколько телефонов, как без ID понять, какой именно обновляется?



![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.017.png)

Такая вот XML получилась. Причем упрощенная. В реальных системах, где хранятся физ лица, данных сильно больше: штук 20 полей самого физ лица, несколько адресов, телефонов, емейл-адресов…

Но прочитать даже огромную XML не составит труда, если вы знаете, что где. И если она отформатирована — вложенные элементы сдвинуты вправо, остальные на одном уровне. Без форматирования будет тяжеловато…

А так всё просто — у нас есть элементы, заключенные в теги. Внутри тегов — название элемента. Если после названия идет что-то через пробел: это атрибуты элемента.

## XML пролог

Иногда вверху XML документа можно увидеть что-то похожее:
```sh
<?xml version="1.0" encoding="UTF-8"?>
```

Эта строка называется XML прологом. Она показывает версию XML, который используется в документе, а также кодировку. Пролог необязателен, если его нет — это ок. Но если он есть, то это должна быть первая строка XML документа.

*UTF-8* — кодировка XML документов по умолчанию.


А простому пользователю вашего SOAP API схема помогает понять, как составить запрос. Кто такой «простой пользователь»?

1. Разработчик системы, использующей ваше API — ему надо прописать в коде, что именно отправлять из его системы в вашу.
1. Тестировщик, которому надо это самое API проверить — ему надо понимать, как формируется запрос.


Да-да, в идеале у нас есть подробное ТЗ, где всё хорошо описано. Но увы и ах, такое есть не всегда. Иногда ТЗ просто нет, а иногда оно устарело. А вот схема не устареет, потому что обновляется при обновлении кода. И она как раз помогает понять, как запрос должен выглядеть.

## Коментарии

Не могут быть внутри тэга
```sh
<plants><!--native --></plants>
```
Используется двойное тире
```sh
<!--native –frost-->
```

## Текстовые данные


• Существуют 5 заданных сущностей
```sh 
<weather>Sunny &amp; &gt; 32<weather>
```
• Использование СDATA

![](Aspose.Words.92fa51d9-20ed-47c8-afd6-6c7b45009a55.018.png)

## В чем преимущества использования XML?

**Поддержка межделовых транзакций**
Когда компания продает товар или сервис другой компании, им необходимо обмениваться такой информацией, как стоимость, спецификации и графики поставок. С помощью расширяемого языка разметки (XML) они могут обмениваться всей необходимой информацией в электронном виде и автоматически закрывать сложные сделки без вмешательства человека. 
**Поддержание целостности данных**
XML позволяет передавать данные вместе с описанием данных, предотвращая потерю целостности данных. Эту описательную информацию можно использовать для выполнения указанных ниже действий.
- Проверьте точность данных
- Автоматическая настройка представления данных для разных пользователей
- Согласованное хранение данных на нескольких платформах  

**Повысьте эффективность поиска**
Компьютерные программы, такие как поисковые системы, могут сортировать и классифицировать XML-файлы более эффективно и точно, чем другие типы документов. Например, слово *туши* может быть существительным или глаголом. На основе тегов XML поисковые системы могут точно классифицировать *метки* для релевантных результатов поиска. Таким образом, XML помогает компьютерам более эффективно интерпретировать естественный язык.
**Разработка гибких приложений**
С помощью XML можно удобно обновлять или изменять дизайн приложения. Многие технологии, особенно новые, имеют встроенную поддержку XML. Они могут автоматически читать и обрабатывать файлы данных XML, чтобы вы могли вносить изменения без необходимости переформатирования всей базы данных.

## В чем недостатки использования XML?
**Синтаксис XML избыточен.**
Размер XML-документа существенно больше бинарного представления тех же данных. В грубых оценках величину этого фактора принимают за 1 порядок (в 10 раз).
Размер XML-документа существенно больше, чем документа в альтернативных текстовых форматах передачи данных (например JSON, YAML, Protocol Buffers) и особенно в форматах данных, оптимизированных для конкретного случая использования.
Избыточность XML может повлиять на эффективность приложения. Возрастает стоимость хранения, обработки и передачи данных.
**Неоднозначность моделирования.**
Нет общепринятой методологии для моделирования данных в XML, в то время как для реляционной модели и объектно-ориентированной такие средства разработаны и базируются на реляционной алгебре, системном подходе и системном анализе.
В природе есть множество объектов и явлений, для описания которых разные структуры данных (сетевая, реляционная, иерархическая) являются естественными, и отображение объекта в неестественную для него модель является болезненным для его сути. В случае с реляционной и иерархической моделями определены процедуры декомпозиции, обеспечивающие относительную однозначность, чего нельзя сказать о сетевой модели.
В результате большой гибкости языка и отсутствия строгих ограничений, одна и та же структура может быть представлена множеством способов (различными разработчиками), например, значение может быть записано как атрибут тега или как тело тега и т. д. Например:
```sh
<a b="1" c="1"/>
<a><b>1</b><c>1</c></a>
<a><b value="1"/><c value="1"/></a>
<a><fields b="1" c="1"/></a> и т. д.
```
Поддержка многих языков в именовании тегов дает возможность назвать, например вес русским словом, в таком случае компьютер никак не сможет установить соответствия этого поля с полем weight в англоязычной версии программы и с полями в версиях модели объекта на множестве других языков.
XML не содержит встроенной в язык поддержки типов данных. В нём нет строгой типизации, то есть понятий «целых чисел», «строк», «дат», «булевых значений» и т. д.
**Пространства имён XML сложно использовать и их сложно реализовывать в XML-парсерах.**
**Существуют другие, обладающие сходными с XML возможностями, текстовые форматы данных, которые обладают более высоким удобством чтения человеком или большей компактностью (YAML, JSON, SweetXM, XF).**

## Каковы области применения XML? 
Расширяемый язык разметки (XML) является базовой технологией тысяч приложений, начиная от обычных инструментов повышения производительности, таких как обработка текстов, и заканчивая программным обеспечением для публикации книг и даже сложными системами настройки приложений.
## Передача данных

Можно использовать XML для передачи данных между двумя системами, в которых одни и те же данные хранятся в разных форматах. Например, на вашем веб-сайте даты хранятся в формате ММ/ДД/ГГГГ, а в бухгалтерской системе даты хранятся в формате ДД/ММ/ГГГГ. Вы можете перенести данные с веб-сайта в систему бухгалтерского учета с помощью XML. Ваши разработчики могут писать код, который автоматически преобразует указанное ниже.

- Данные веб-сайта в формате XML
- Данные XML к данным системы бухгалтерского учета
- Данные системы бухгалтерского учета возвращаются в формат XML
- XML-данные возвращаются к данным веб-сайта
## Интернет-приложения
XML обеспечивает структуру данных, которые вы видите на веб-страницах. Другие технологии веб-сайта, такие как HTML, работают с XML для представления посетителям веб-сайта согласованных и релевантных данных. Например, рассмотрим веб-сайт электронной коммерции, на котором продается одежда. Вместо того, чтобы показывать всю одежду всем посетителям, веб-сайт использует XML для создания настраиваемых веб-страниц на основе предпочтений пользователя. Он показывает товары определенных брендов, выполняя фильтрацию по тегу <brand>.
## Документация
Можно использовать XML для указания структурной информации любого технического документа. Другие программы затем обрабатывают структуру документа для ее гибкого представления. Например, существуют теги XML для абзаца, элемента в нумерованном списке и заголовка. Используя эти теги, другие типы программного обеспечения автоматически подготавливают документ к использованию, например, к печати и публикации на веб-странице.
## Тип данных
Многие языки программирования поддерживают XML в качестве типа данных. Благодаря этой поддержке вы можете легко писать программы на других языках, которые работают непосредственно с файлами XML.

## Используемая литература
https://studfile.net/preview/3021529/
https://serpstat.com/ru/blog/chto-takoe-jazyk-xml/
https://fb.ru/article/453630/xml-primer-funktsii-i-vozmojnosti-plyusyi-i-minusyi-formata
https://intuit.ru/studies/courses/485/341/lecture/8204
http://bourabai.ru/xml/
