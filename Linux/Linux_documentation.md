# Справочник Linux. Основные команды терминала Linux. #

### **Что такое Linux?** ###

Linux - семейство Unix - подобных операционных систем, использующих ядро Linux.  
В свою очередь, Unix представляет собой семейство переносимых, многозадачных и многопользовательских операционных систем. Операционные системы семейства Unix характеризуются модульным дизайном, в котором каждая задача выполняется отдельной утилитой, взаимодействие осуществляется через единую файловую систему, а для работы с утилитами используется командная оболочка.  

Рассмотрим следующие возможности ОС Linux:  
+ Многозадачность  
У ядра Linux есть функция разделения времени центрального процессора. Суть функции заключается в том, что ядро по очереди выделяет отрезок времени для выполнения каждой задачи. Таким образом, все процессы происходят независимо и не мешают друг другу.

+ Многопользовательский доступ   
OC Linux поддерживает одновременную работу нескольких пользователей, обеспечивая им все системные ресурсы с помощью различных удаленных терминалов. Точно так же, как и в других ОС, пользователей можно делить на группы и ограничивать их возможности чтения, записи и запуска на исполнение.

+ Страничная организация памяти   
Организация системной памяти Linux выполнена в виде страниц объемом 4K. В случае, если оперативная память закончится, система начнет поиск неиспользуемых страниц для того, чтобы переместить их на жесткий диск, откуда впоследствии их можно будет восстановить.

+ Загрузка выполняемых модулей «по требованию»  
Ядро Linux работает так, что в оперативной памяти находится только нужная часть кода программа, которая используется, а остальные части остаются на диске.

+ Динамическое кэширование диска   
Память, приготовленная для кэша, уменьшается, если компьютеру или пользователю необходимо больше места.

+ Запуск программ для других ОС   
Для того, чтобы запуск программ, разработанных для других ОС, был возможен на ПК с Linux, там установлены эмуляторы DOS, Windows 3.1 и Windows 95.
    
Операционные системы, использующие ядро Linux, называются дистрибутивами Linux. Они обладают сразу несколькими важными свойствами:
1. Главная "фишка" ОС Linux состоит в том, что она бесплатно в соответствии с GNU (свободного и открытого программного обеспечения). В сравнении с привычной всем ОС Windows, за нее придется заплатить где - то $100-$200.

2. Их исходный код является открытым. Это означает, что у любого пользователя есть право изучать и изменять исходный код. Таким образом, можно сделать вывод, что ОС Линукс никому не принадлежит. Точнее можно сказать, что она принадлежит сообществу программистов. Каждый желающий может вносить свои изменения, которые в дальнейшем принимаются сообществом.
    


Существуют множество видов дистрибутивов Linux. Самыми распространёнными в мире дистрибутивами являются:
1. Ubuntu (http://releases.ubuntu.com/)
2. Debian (https://www.debian.org/)
3. Astra Linux (https://astralinux.ru/)
4. Linux Mint (https://linuxmint.com/)
5. Red Hat Linux (https://www.redhat.com/en)
6. CentOS (https://www.centos.org/)
7. openSUSE (https://www.opensuse.org/)
8. Fedora (https://getfedora.org/)

### **Инструкция по установке Linux** ###
На просторах интернета очень много подробных инструкций по установке ОС Linux либо параллельно с другой операционной системой, либо используя виртуальную машину. Здесь я приведу лишь некоторые ссылки на полезный материал.
1. Установка Linux параллельно с OC Windows  
https://lumpics.ru/how-to-install-linux-beside-windows-7/ - инструкция по установке Linux рядом с "вечной" Windows 7.  
https://blog.sedicomm.com/2022/05/09/kak-ustanovit-linux-ubuntu-ryadom-parallelno-s-windows-10-podrobnaya-instrukcziya-dlya-nachinayushhih/ - инструкция по установке Linux рядом с Windows 10.  

На самом деле порядок действий практически никак не отличается в зависимости от версии Windows. Я лично устанавливал Ubuntu параллельно с Windows 10. Мой совет это очень внимательно разделять место на диске, потому что я лично столкнулся с проблемой, что выделил очень мало места на диск для Ubuntu и это в дальнейшем привело к некоторым проблемам. И конечно же при выборе диска для загрузки ОC Linux не выбирайте диск, на котором установлен Windows, потому что так вы случайно удалите Windows.

2. Установка Linux, используя Virtual Machine  
https://youtu.be/vY9QNwX_IsY - хороший видеоурок для установки Linux с VirtualBox. 

Хотелось бы сказать, что каждый сам для себя определяет удобный ему способ работы с ОС Linux, но для слабых машин я бы советовал устанавливать Linux параллельно с основной операционной системой.  

Возможно, вы хотели бы попрактиковаться в использовании команд Linux или просто протестировать свои скрипты. Все это можно сделать при помощи онлайн-терминалов Linux и компиляторов bash. Они полезны тем, что вам не придется устанавливать Linux на свою машину. Ниже приведена ссылка на список одних из самых лучших онлайн терминалов Linux:  
https://techrocks.ru/2019/10/30/best-online-linux-terminals/

### **Особенности файловой структуры Linux** ### 
При работе с Linux нужно держать в голове концепцию, которая лежит в основе системы: «Всё — это файл». Расшифровывается просто: любые данные и процессы операционной системы можно выразить как поток байтов, занимающий определённый объём файловой системы на дисковом накопителе. 

Соответственно, всё, что занимает место, можно назвать файлом. А уж файлы можно структурировать: 
1. обычные файлы  
    1.1. текстовые  
    1.2 бинарные  
    1.3. файлы изображений  
    1.4. архивы
2. специальные  
    2.1 блочные для обозначения устройств (b)  
    2.2. символьные (с)  
    2.3 ссылочные для представления символьных ссылок (l)  
    2.4 файлы сокетов для связи между разными процессами (s)  
    2.5 директории — файлы, в которых хранятся другие файлы (d)

Linux-системы имеют много общего, и файловая структура — одна из этих общих черт. Знакомство с ней поможет увереннее ориентироваться в операционной системе в целом. Давайте погрузимся немного поглубже и посмотрим, что лежит в корне Linux-системы.

Собственно, в корне, или корневой директории «/», лежат все данные сервера, распределённые по разным каталогам. При этом каждый каталог имеет своё значение и содержит файлы, сгруппированные по определённому критерию. По умолчанию структура директорий состоит из папок:  
* **/bin**  
Содержит исполняемые бинарные файлы различных служб, доступные для запуска любым пользователям сервера. Включает и исполняемые файлы базовых команд,
* **/boot**  
Содержимое этого каталога содержит сердце системы — файлы загрузчика и ядра. Без этой директории операционная система не сможет запуститься. 
* **/dev**  
Эта директория содержит файлы устройств, подключенных к серверу. Включает терминал, через который мы отдаём серверу команды (tty*), а также специальные устройства типа null, random, zero. Ну и, конечно, сам диск сервера и его разделы (vda*).
* **/etc**  
Эта директория по умолчанию содержит все конфигурационные файлы служб, а в некоторых случаях — и скрипты для их запуска и отключения. 
* **/home**  
Эта папка предназначена для домашних каталогов пользователей.
* **/lib и /lib64**  
В директории /lib хранятся библиотеки, необходимые для работы системных служб, файлы которых размещены в папках /bin и /sbin. А также данные для загрузки системы и модуля ядра ОС.  
Директория /lib64 предназначена для тех же целей, только включает в себя библиотеки для всех остальных служб сервера.  
* **/media**  
В этой директории операционная система автоматически монтирует внешние устройства (USB, CD-ROM и пр.).
* **/mnt**  
Эта папка выполняет аналогичные /media функции — используется для временного монтирования внешних устройств. Преимущественно вручную.
* **/opt**  
В эту папку обычно устанавливается пользовательское программное обеспечение. 
* **/proc**  
В этом каталоге хранятся процессы и системная информация ОС, представленная в виде файлов, так называемая «виртуальная файловая система». Все данные в этом разделе генерируются автоматически и обновляются на лету.
* **/root**  
Домашняя папка для корневого пользователя root.
* **/run**  
Этот каталог включает в себя данные, обрабатываемые и хранимые в оперативной памяти — например, PID процессов, информацию о ходе их выполнения, активные сокеты и пр. Так называемая временная файловая система. Она сбрасывается при каждой перезагрузке сервера.
* **/sbin**  
Как и /bin, содержит исполняемые бинарные файлы системных служб. Но, в отличие от /bin, только служб, запуск которых возможен исключительно с правами администратора.
* **/srv**  
Эта папка предназначена для сервисных нужд — чтобы пользователи сервера могли найти какие-то общедоступные данные для конкретной службы, например, веб-сервера, FTP-сервера. По умолчанию не содержит данных.
* **/sys**  
Ещё одна директория, содержащая виртуальную файловую систему. В этот раздел экспортируются данные ядра операционной системы и его модулей. Этот каталог перезаписывается после каждой перезагрузки операционной системы. 
* **/tmp**  
Эта папка используется операционной системой и различными внутренними службами для хранения временных файлов. 
* **/usr**  
В этом каталоге хранятся исполняемые файлы, библиотеки и файлы документации (man) для внутренних служб, компоненты ядра для функционирования операционной системы, а также данные программ, установленных пользователями.
* **/var**  
Директория /var содержит часто изменяемые данные. Например, кэши (/var/cache), логи (/var/log), очереди (/var/spool). Здесь же по умолчанию хранятся данные сайтов (/var/www), сервера баз данных (/var/lib/mysql), почтового сервера (/var/mail → /var/spool/mail).

### **Основные команды терминала Linux** ###    

Одним из коренных отличий семейства ОС Linux от ОС Windows является ведущая роль командной строки или терминала в администрировании системы. Для успешной работы с «Линукс» одного графического интерфейса недостаточно. Полноценное управление тут возможно только через терминал. А в работе с терминалом никак не обойтись без изучения основных команд Linux.

Для того, чтобы открыть терминал по умолчанию используется сочетание клавиш CTRL+ALT+T. После этого перед пользователем появится рабочее окно терминала. Теперь можно начать изучение основных команд терминала.

#### **Базовые команды для работы с терминалом:** ####
1. **clear**  
Очищает всю выведенную в консоль информацию. Пригодится на тот случай, если терминал будет забит выводом других команд или содержимом ранее открытых документов. 

2. **history**  
Отображает ранее введенные команды. По умолчанию показывает 10 последних, но при желании это значение можно изменить, добавив в качестве параметра любое число. Например, history 17, чтобы показать 17 последних выполненных операций.

3. **man**  
 Показывает инструкцию к программам и командам Linux. Чтобы получить руководство для программы, наберите:
 ```
 man имя_программы
 ```
 Для инструкции по команде, введите:
 ```
 man имя_команды
 ```

4. **whatis**  
Выводит краткое описание программы.
 ```
 whatis имя_программы
 ```

5. **whereis**  
Показывает полный путь к исполняемому файлу и другим файлам программы.
 ```
 whereis имя_программы
 ```

6. **file**  
Показывает к какому типу относится файл. Особенность Linux в том, что рабочие файлы могут и не иметь расширения. Поэтому у пользователя могут возникнуть проблемы с идентификацией файлов, которые снимает эта команда.
 ```
 file имя_файла
 ```

7. **help**  
Выводит в терминал необходимую информацию о команде
 ```
 имя_команды --help
 ```

8. **whoami**  
Команда показывает действительный идентификатор пользователя

9. **TAB**  
Показывает варианты автозавершения команды. Нажатие клавиши табуляция после определённой команды или их последовательности выводит подсказку с вариантами возможного продолжения команды.

10. **Ctrl + R**  
Это сочетание клавиш помогает запустить обратный поиск по всем параметрам, связанным с указанной командой. Достаточно лишь указать ключевое слово для поиска. Есть серьёзный минус – за раз можно увидеть только 1 результат. Выйти из режима реверсивного поиска поможет комбинация Ctrl + C.
11. **CTRL +C**  
Завершает выполнение любого процесса в терминале.
12. **CTRL +Z**  
Cтавит на паузу выполнение любого процесса в терминале. Снова запустить его можно, введя %.
13. **alias**  
Команда создаёт синонимы для других команд Linux. То есть вы можете делать новые команды или группы команд, а также переименовывать существующие. Это очень удобно для сокращения длинных команд, которые вы часто используете, или создания более понятных имен для команд, которые вы используете нечасто и не можете запомнить.
```
alias имя="значение"
alias имя="команда аргумент1 аргумент2"
alias имя="/путь/к/исполняемому/файлу"
```
14. **&&**    
Строго говоря, это не команда. Если вы хотите выполнить сразу несколько команд, поставьте между ними двойной амперсанд вот так:
```
первая_команда && вторая_команда
```

#### Команды прав суперпользователя ####
1. **sudo**  
Позволяет исполнять команды с правами суперпользователя. Перед переходом в режим root администратора система выполнит запрос пароля и логина root.
 ```
 sudo имя_команды
 ```
 
2. **sudo su**  
Переводит терминал в режим суперпользователя. В нем каждая введенная команда будет восприниматься системой так, будто перед ней ввели sudo. Помогает запускать несколько скриптов и утилит, требующих права администратора, без необходимости постоянно корректировать их или вводить пароль от учетной записи.

3. **sudo gksudo**  
Осуществляет запуска приложений от имени суперпользователя, использующих не терминал, а графический интерфейс.
 ```
 sudo gksudo имя_приложения
 ```
 
4. **sudo !!**  
Запускает предыдущую команду от имени администратора.

5. **chmod**  
Корректирует права доступа к выбранному файлу. Применяется исключительно с набором аргументов, обозначающих список прав.  
Сначала рассмотрим какими бывают права доступа linux и как они устанавливаются. Пред этим рекомендую прочитать статью про права, ссылка на которую есть выше. Есть три основных вида прав:
 * r - чтение;
 * w - запись;
 * x - выполнение;
 * s - выполнение  от имени суперпользователя (дополнительный);  
 
 Также есть три категории пользователей, для которых вы можете установить эти права на файл linux:
 * u - владелец файла;
 * g - группа файла;
 * o - все остальные пользователи;
 
 Синтаксис настройки прав такой:
 ```
 chmod пользователь действие вид_прав
 ```
 В качестве действий могут использоваться знаки "+" - включить или "-" - отключить. Рассмотрим несколько примеров:
 * u+x - разрешить выполнение для владельца;
 * ugo+x - разрешить выполнение для всех;
 * o-x - запретить выполнение для остальных пользователей;
 * ugo+rwx - разрешить все для всех;
 
 Но права можно записывать не только таким способом. Есть еще восьмеричный формат записи, он более сложен для понимания, но пишется короче и проще:
 * 0 - никаких прав;
 * 1 - только выполнение;
 * 2 - только запись;
 * 3 - выполнение и запись;
 * 4 -  только чтение;
 * 5 - чтение и выполнение;
 * 6 - чтение и запись;
 * 7 - чтение запись и выполнение.
 
 Права на папку linux такие же, как и для файла. Во время установки прав сначала укажите цифру прав для владельца, затем для группы, а потом для остальных. Например:
 * 744 - разрешить все для владельца, а остальным только чтение;
 * 755 - все для владельца, остальным только чтение и выполнение;
 * 764 - все для владельца, чтение и запись для группы, и только чтение для остальных;
 * 777 - всем разрешено все.
 
 Самый частый случай - разрешить выполнения скрипта владельцу:
 ```
 chmod u+x имя_файла
 ```
 
6. **chown**  
Назначает владельца для выбранной директории, документа, картинки или любого другого элемента в файловой системе. 
 ```
 chown имя_владельца имя_файла 
 ```

#### Команды для управления пользователями #### 

1. **useradd**  
Создает новую учетную запись.
```
useradd имя_нового_пользователя
```

2. **passwd**  
Задает пароль для нового пользователя.
```
passwd имя_нового_пользователя
```
3. **userdel**  
Удаляет выбранную учетную запись
```
userdel имя_пользователя
```

#### **Установка, удаление и обновление пакетов (для Debian и Ubuntu)** ####
1. **sudo apt-get install**  
Устанавливает программу, указанную в качестве параметра.
```
sudo apt-get install название_пакета
```
2. **sudo apt-get update**  
Обновляет информацию о пакетах, имеющихся в системе.
```
sudo apt-get update
```
3. **sudo apt-get upgrade**  
Обновляет установленные пакеты до самых свежих версий.
```
sudo apt-get upgrade
```
4. **sudo apt-get remove**  
Удаляет пакет
```
sudo apt-get remove название_пакета
```

#### **Управления файлами и каталогами** ####
1. **ls**  
С помощью этой утилиты можно посмотреть, что содержится в папке. Без указания конкретного пути показывает текущий каталог. Если путь указан, то переход совершиться в конечный его каталог. Чтобы вывести каталог в виде списка с дополнительной поясняющей информацией введите
```
ls -l
```
2. **cd**  
Меняет текущий каталог, в котором работает терминал на указанный.
```
cd путь_до_каталога
```
Когда терминал запущен, он использует по умолчанию корневой каталог (root), вернуться в который можно, набрав:
```
cd ~
```
Чтобы подняться по древу каталогов на уровень вверх набираем: 
```
cd ..
```
Чтобы вернуться к предыдущей директории:
```
cd -
```
3. **pwd**  
Укажет полный путь до директории, в которой вы находитесь.
4. **mv**  
Применяется для перемещения файлов из одной папки в другую
```
mv путь_до_файла место_назначения
```
Эту же команду используют, чтобы поменять имя файла. Для этого надо не указывать папку для перемещения, а просто ввести новое название для документа.
```
mv имя_файла новое_имя_файла
```
Данная команда применяется и для директорий. Синтаксис при этом сохраняется.
5. **ср**  
Используем, если нужно не переместить файл, а создать его копию в другой директории. Работает так же, как и mv. Указываем путь до файла, который нужно скопировать, и путь до директории, куда копируем. Данная команда применяется и для директорий. Синтаксис при этом сохраняется.
6. **rm**  
Опасная команда для удаления директорий и их содержимого. Затирает все данные, которые обнаружит в указанной папке. То есть все субдиректории и файлы будут уничтожены. И восстановить их не получится. Про корзину этой команде ничего неизвестно. Флаг -r применяется для рекурсивного удаления.
```
rm -r путь_до_директории
```
7. **mkdir**  
Создает новую директорию. 
```
mkdir путь_до_места_создания/имя_директории
```
8. **rmdir**  
Удаляет пустую папку. Акцентируем внимание на слове «пустую». В отличие от rm, rmdir не трогает другие файлы и субдиректории.
```
rmdir путь_до_папки
```
9. **cat**  
Показывает содержимое текстовых документов.
```
cat имя_файла
```
Также cat «склеивает» несколько переданных подряд файлов в один
```
cat файл_№1 файл_№2 > файл_№3
```
10. **tail**  
В некоторых случаях нам не нужно смотреть весь файл, иногда достаточно посмотреть только то, что находится в конце файла. Для этого можно использовать команду tail, она позволяет выводить заданное количество строк с конца файла. По умолчанию выводит 10 последних строк.
```
tail имя_файла
```
Если вам недостаточно 10 строк и нужно намного больше, то вы можете увеличить этот параметр с помощью опции -n:
```
tail -n количество_строк имя_файла
```
11. **head**  
Команда head выводит начальные строки (по умолчанию — 10) из одного или нескольких документов.
```
head имя_файла
```
Если вам недостаточно 10 строк и нужно намного больше, то вы можете увеличить этот параметр с помощью опции -n:
```
head -n количество_строк имя_файла
```
12. **find**  
Продвинутая команда по поиску объектов в файловой системе Linux. Можно искать элементы как по названию, так и по иным характеристикам
```
find -name имя_файла
```
13. **grep**  
find ищет файлы и директории, а grep ищет текст в их содержимом.
```
grep имя_файла|строка_для_поиска
```
14. **wc**  
В Linux команда wc позволяет подсчитать количество строк, слов, символов и байтов в каждом заданном файле или стандартном вводе и распечатать результат.
```
wc имя_файла
```
15. **Linux pipe**  
Pipe (конвеер) – это однонаправленный канал межпроцессного взаимодействия. Конвейеры чаще всего используются в shell-скриптах для связи нескольких команд путем перенаправления вывода одной команды (stdout) на вход (stdin) последующей, используя символ конвеера ‘|’. Например:
```
grep -i “error” ./log | wc -l
43
```
grep выполняет регистронезависимый поиск строки “error” в файле log, но результат поиска не выводится на экран, а перенаправляется на вход (stdin) команды wc, которая в свою очередь выполняет подсчет количества строк.
Для подробного изучения этой темы предлагаю ознакомиться с ссылками на материал в источниках. 

#### Консольные текстовые редакторы Linux ####  
При работе в командной строке довольно часто возникает необходимость создавать или редактировать текстовые файлы, поэтому знакомство с несколькими редакторами будет довольно полезно.  
1. **nano**  
GNU nano — это простой в использовании текстовый редактор командной строки для операционных систем Unix и Linux. Он включает в себя все базовые функции, которые вы ожидаете от обычного текстового редактора, такие как выделение синтаксиса, несколько буферов, поиск и замена с поддержкой регулярных выражений, проверка орфографии, кодировка UTF-8 и многое другое.   
Для работы с nano применяется следующий синтаксис:  
```
nano опции имя_файла
```
Для перемещения по тексту вы можете использовать мышку, стрелки на клавиатуре или специальные сочетания клавиш. В программе нет никакого меню, а все действия выполняются именно с помощью горячих клавиш. Возможно, некоторые из них будет не просто запомнить с первого раза,но после нескольких раз практики все получится. Тем более, что все самое необходимое отображается внизу экрана. Для активации того или иного действия достаточно нажать Ctrl и указанную букву.

2. **vim/vi**  
На данный момент существует две версии редактора - vi и vim. Vim расшифровывается как Vi Improved, улучшенный vi. Это новая версия, которая принесла очень много улучшений. В большинстве современных дистрибутивов используется именно она.   
Текстовый редактор Vim может работать в двух режимах. Это и есть его главная особенность. Первый режим, который используется по умолчанию при открытии редактора - это командный. В этом режиме вы можете вводить команды vi, а также использовать символьные клавиши для управления редактором. Второй режим - обычное редактирование текста, он работает так же как и редактирование текста в nano. Для переключения в командный режим используется клавиша Esc. Для переключения в режим редактирования - клавиша i.  
Для освоения vim требуется много времени и практики. В настоящее время многие спорят о том, действительно ли  vim заслуживает такого внимания, но решать это только вам. В источниках я указал несколько статей, посвященных vim.


#### Команды для отображения базовой информации и управления системой ####
1. **df**  
Показывает, сколько пространства занято на подключенных дисках и разделах. По умолчанию отображает данные в килобайтах. Можно переключиться на мегабайт, добавив параметр -m.
2. **du**  
Расскажет, сколько места занимает конкретный файл или папка. Отображает информацию в блоках. Но это неудобно, поэтому обычно к ней добавляют опцию -h, чтобы появились привычные мегабайты, килобайты и байты.
```
du путь_до_файла -h
```
3. **uname**  
Вывод информации о системе и сервере. Аргумент -a показывает имя компьютера, версию ядра, текущую дату и время, разрядность системы и ее тип.
4. **date**  
Команда отображает текущее время и дату.
5. **shutdown**  
Часто для выключения Linux из терминала используется утилита shutdown. 
Синтаксис команды очень простой:
```
shutdown [опции] [время] [сообщение]
```
Опции задают параметры отключения. Время можно задавать в виде чч:мм в 24 часовом формате. Также можно использовать запись +минуты, указывающую через сколько минут от текущего момента нужно выключить компьютер с Linux. Также доступна константа now, указывающая, что выключать нужно прямо сейчас. Параметр сообщение позволяет задать сообщение, которое будет выведено в терминал перед выключением.  
Вот основные опции утилиты:  
    * --help - вывести справку по программе
    * -H, --halt - отключить питание, не завершая процессы и не перемонтируя файловые системы
    * -P, --poweroff - нормальное выключение
    * -r, --reboot - перезагрузка
    * -k - не выполнять реальных действий, а только вывести сообщение
    * --no-wall - выключить компьютер, но не выводить сообщение
    * -c - отменить запланированное выключение linux из командной строки
    
6. **reboot**  
Команда выполняет перезагрузку системы.  
reboot c ключом -p выключает компьютер 
```
reboot -p
```
7. **halt**  
Эта команда тоже выключает компьютер. Только делает она это очень по-своему. Она не выполняет никаких подготовительных действий перед выключением, а просто отключает питание:
```
sudo halt
```
Использование halt может повредить систему.
8. **poweroff**  
Это аналог halt, делает в точности то же самое.

#### Команды Linux для управления сетью ####
1. **ip**  
Команда позволяет посмотреть сетевые интерфейсы и IP адреса им присвоенные, посмотреть и настроить таблицу маршрутизации, включать или отключать сетевые интерфейсы, управлять маршрутизацией и ARP, а также многое другое.   
Сначала рассмотрим синтаксис команды:
```
ip [опции] объект команды [параметры]
```
Опции - это глобальные настройки, которые сказываются на работе всей утилиты независимо от других аргументов, их указывать необязательно.    
Объект - это тип данных, с которым надо будет работать, например: адреса, устройства, таблица arp, таблица маршрутизации и так далее;  
Команды - какое-либо действие с объектом;  

 Теперь рассмотрим самые важные объекты:  
 * address или a - сетевые адреса;
 * link или l - физическое сетевое устройство;
 * neighbour или neigh - просмотр и управление ARP;  
 * route или r - управление маршрутизацией;  
 * rule или ru - правила маршрутизации;  
 * tunnel или t - настройка туннелирования.

 Теперь рассмотрим доступные команды, с помощью которых может быть выполнена настройка сети linux. Они зависят от объекта, к которому будут применяться. Вот основные команды: add (добавить ip адрес), change, del или delete (удаление ip адреса), flush (удаление всех ip адресов), get, list или show (показать ip адрес), monitor, replace, restore, save, set (включение и выключение интерфейсов), и update. Если команда не задана, по умолчанию используется show.  
 Так как этот материал является лишь кратким руководством по знакомству с командами Linux для того, чтобы ознакомиться подробнее с командой ip используйте команду: 
 ```
 ip help
 ```
или перейдите по ссылке, которая указана в источниках.

2. **ping**  
Утилита ping - это очень простой инструмент для диагностики сети. Она позволяет проверить доступен удаленный хост или нет и все. Для этого утилита проверяет, может ли хост отвечать на сетевые запросы с помощью протокола ICMP.  
Все данные по сети передаются в виде небольших пакетов. Программа передает небольшой пакет с данными ICMP и ожидает получить обратно пакет ответа, если получает, то считается что удаленный узел доступен. ICMP или Internet Control Message Protocol - это надстройка над протоколом IP, которая используется для передачи служебных сообщений и сообщений и ошибках.  
Синтаксис команды:  
```
ping опции адрес_узла
```

3. **traceroute**  
Не всегда сеть работает так, как от нее требуется, иногда определенный компьютер в вашей локальной сети компании, или удаленный может не отвечать. Казалось бы, все работает, все подключено, но похоже на каком-то из узлов, на пути от вашего компьютера, до нужного случается ошибка.  
Утилита ping позволяет только определить наличие проблемы, что узел не отвечает, но как узнать где обрывается соединение? Для этого применяется утилита traceroure.  
Вся информация в сети передается в виде пакетов. Поток данных разбивается специальным программным обеспечением на небольшие пакеты и передается через сеть интернет на целевой узел, а там собирается обратно.  
 Каждый пакет проходит на своем пути определенное количество узлов, пока достигнет своей цели. Причем, каждый пакет имеет свое время жизни. Это количество узлов, которые может пройти пакет перед тем, как он будет уничтожен. Этот параметр записывается в заголовке TTL, каждый маршрутизатор, через который будет проходить пакет уменьшает его на единицу. При TTL=0 пакет уничтожается, а отправителю отсылается сообщение Time Exceeded. 
Команда traceroute linux использует UDP пакеты. Она отправляет пакет с TTL=1 и смотрит адрес ответившего узла, дальше TTL=2, TTL=3 и так пока не достигнет цели. Каждый раз отправляется по три пакета и для каждого из них измеряется время прохождения. Пакет отправляется на случайный порт, который, скорее всего, не занят. Когда утилита traceroute получает сообщение от целевого узла о том, что порт недоступен трассировка считается завершенной.   
Имея подобную информацию на руках, очень просто понять, на каком узле возникла проблема, если сеть дала сбой.
  
  Синтаксис команды:
  ```
  traceroute опции адрес_узла
  ```

#### Команды для управления процессами ####
Процесс Linux - это экземпляр программы, запущенный в памяти. Все процессы можно разделить на обычные и фоновые.  
Linux - это многопользовательская система, каждый пользователь может запускать одни и те же программы, и даже один пользователь может захотеть запустить несколько экземпляров одной программы, поэтому ядру нужно как-то идентифицировать такие однотипные процессы. Для этого каждому процессу присваивается PID (Proccess Identificator).
1. **ps**  
Вывести на экран список текущих процессов, запущенных пользователем, можно командой ps.  
Чтобы посмотреть список всех процессов с дополнительной информацией, вводим:
```
ps aux
```
Теперь список процессов будет выводится в более подробном формате, но для нас главными являются параметры USER (пользователь, который запустил процесс) и PID (уникальный идентификатор процесса).  
Используя команду grep мы также можем найти процесс по его имени:
```
ps aux | grep имя_процесса
```

2. **kill**  
После того как мы узнали PID процесса мы можем его прекратить используя специальную команду:
```
kill <PID>
```
Если процесс не завершается, убиваем его принудительно с помощью ключа -9:
```
kill -9 <PID>
```
3. **xkill**  
После того как вы введете в терминал команду xkill курсор мыши заменится на значок "креста" и вы должны будете нажать левой кнопкой мыши на программу, которую вы хотите завершить, и процесс завершится.
4. **killall**  
Команда killall в Linux предназначена для «убийства» всех процессов, имеющих одно и то же имя. Это удобно, так как нам не нужно знать PID процесса.
```
killall имя_процесса
```
5. **top**  
Команда top показывает запущенные в Linux процессы программ и служб.  
С помощью top можно наблюдать в реальном времени динамику работающей системы. Программа показывает обобщённую информацию по системе, а также список процессов или потоков, обслуживающихся в настоящее время ядром Linux.  
В целом это очень удобная программа для мониторинга процессов, но ее изучение требует небольших затрат. Более подробная информация изложена в источниках.
6. **htop**  
Команда htop похожа на команду top по выполняемой функции: они обе показывают информацию о процессах в реальном времени, выводят данные о потреблении системных ресурсов и позволяют искать, останавливать и управлять процессами.  
У обеих команд есть свои преимущества. Например, в программе htop реализован очень удобный поиск по процессам, а также их фильтрация. В команде top это не так удобно — нужно знать кнопку для вывода функции поиска. ато в top можно разделять область окна и выводить информацию о процессах в соответствии с разными настройками. В целом top намного более гибкая в настройке отображения процессов.   

ЗАКЛЮЧЕНИЕ: top и htop очень похожи по функционалу и какую утилиту использовать решать только вам. Стоит также учесть, что top и htop перед использованием необходимо установить.

#### Команды для компиляции и запуска программ (С/С++) ####
Предисловие: перед использованием следующих команд установите необходимый компилятор. На просторах интернета достаточно много понятных статей, как это можно сделать.
Чтобы скомпилировать программу, написанную на "С", запустите:
```
gcc -Wall -o имя_программы.с имя_программы
-Wall - выведет все предупреждения для вашей программы
```
Чтобы скомпилировать программу, написанную на "С++", запустите:
```
g++ -Wall -o имя_программы.сpp имя_программы
-Wall - выведет все предупреждения для вашей программы
```
Для запуска программы:
```
./имя_програмы
```

#### **Список источников** ####
1. Основные команды Linux - https://losst.ru/42-komandy-linux-kotorye-vy-dolzhny-znat
2. Информация о Linux pipe - https://andreyex.ru/linux/chto-takoe-kanaly-pipe-v-linux-kak-rabotaet-perenapravlenie-kanalov, https://habr.com/ru/post/195152/
3. Подробная информация про команду ip - https://losst.ru/nastrojka-seti-v-linux
4. Инструкция top - https://zalinux.ru/?p=1811
5. Инструкция htop - https://zalinux.ru/?p=3581
6. Текстовые консольные редакторы Linux - https://losst.ru/luchshie-tekstovye-redaktory-linux
7. Редактор vim - https://losst.ru/kak-polzovatsya-tekstovym-redaktorom-vim, https://habr.com/ru/company/ruvds/blog/544160/


#### **Заключение** ####
Данная статья не является полным курсом по знакомству с командами терминала Linux, так как количество команд является достаточно объемным. Более подробно можно познакомиться с командами и их уникальными особенностями только при постоянной практики, но главной целью всех команд является упрощение взаимодействия пользователя с системой. Я буду рад, если опытные пользователи Linux укажут на допущенные мной ошибки для дальнейшего усовершенствовавия статьи.
