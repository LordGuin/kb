
# Содержание

1. [Git Bash](#Git_Bash)
2. [Создание нового репозитория локально](#Создание_нового_репозитория_локально)
3. [Commit](#Commit)
4. [Github](#Github)
5. [Merge](#Merge)
6. [Rebase](#Rebase)
## Git Bash
* [Git Bash](https://git-scm.com/downloads) - это эмулятор терминала для операционных систем, который предоставляет пользователю доступ к командам Git и утилитам командной строки, позволяя работать с репозиториями Git и выполнять различные операции через командную строку.
## Создание нового репозитория локально
* Открываем Git Bash перед вами появляется вот такое вот окно:
  
  ![Окно Git Bash](./img/изображение_2023-10-02_135532176.png)
* Если у вас уже есть проект в каталоге, который не находится под версионным контролем Git, то для начала нужно перейти в него. Если вы не делали этого раньше, то для разных операционных систем это выглядит по-разному:

для Linux:
```shell
$ cd /home/user/my_project
```
для Windows:
```shell
$ cd C:/Users/user/my_project
```
* Если у вас нет проекта в каталоге, то создаем свою папку в удобном для вас месте и переходим в созданную нами директоию командой выше:
```shell
$ mkdir C:/Users/user/[имя проекта]
```
* а затем выполните команду:

```shell
$ git init
```
  Эта команда создаёт в текущем каталоге новый подкаталог с именем .git, содержащий все необходимые файлы репозитория — структуру Git репозитория. На этом этапе ваш проект ещё не находится под версионным контролем. Подробное описание файлов, содержащихся в только что созданном вами каталоге .git
  
![Git](./img/изображение_2023-10-02_143912695.png)

* Команда 
```shell
$ git status
``` 
отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются Git. Информация об истории коммитов проекта не отображается при выводе данных о состоянии. Для этого используется команда 
```shell
$ git log
```
![Git](./img/изображение_2023-10-02_144310432.png)

Как мы видим на данный момент у нас нет коммитов на ветке master и сам git предлогает создать файл и добавить его. Давайте сделаем это:
```shell
$ nano test.py
```
Напишем простенькую программу, далее нажимам ctrl+O и для выхода ctrl+X:
```python
print("I'am Learn git")
```
* Далее нажимам ctrl+O и для выхода ctrl+X
* Проверим git status видим наш новый файл. Команда `git add` используется для добавления изменений в рабочей директории в индекс, так чтобы они затем могли быть включены в новый коммит. Она позволяет выбрать конкретные файлы или директории для подготовки к коммиту, фиксируя только изменения, которые должны быть включены. Теперь добавим test.py с помощью команды:
```shell
$ git add test.py
```
* Или если у вас несколько файлов можно добавить их все одной командой:
```shell
$ git add --all
or
$ git add .
```
![Git add](./img/изображение_2023-10-02_145847819.png)
# Commit
В Git "commit" представляет собой операцию сохранения изменений в репозитории. Каждый коммит создает новую точку в истории проекта, записывая состояние всех файлов на момент сохранения. Коммиты позволяют отслеживать изменения, возвращаться к предыдущим версиям кода и сотрудничать с другими разработчиками.
Также Git хранит всю историю о том, когда какой коммит был сделан и кем. [Подробнее о хранение данных в Git.](https://github.com/nnstu-appmath/kb/blob/5_git_introduction/Git/git-architecture.md#хранение-данных-в-git)
* ![S](./img/три%20основные%20секции%20проекта.png)

**Файлы в репозитории могут находиться в 3 различных “областях”.**

1. HEAD
2. Индекс
3. Рабочий каталог
* Индекс в Git — это специальная промежуточная область, в которой хранятся изменения файлов на пути от рабочей директории до репозитория. При выполнении коммита в него попадают только те изменения, которые были добавлены в индекс.
* Рабочий Каталог это ваша папка с файлами
* HEAD - это просто ссылка на объект фиксации, т.е commit.

* Теперь сделаем наш первый коммит, выполнив команду:
```shell
$ git commit -m "First commit"
```
* Тем самым мы сохраним содержимое области Индекс как неизменяемый снимок в области HEAD. Обязательно нужно описать суть внесенных вами изменений, для этого используется флаг -m.
* Все, коммит готов. И файл попал в область HEAD. HEAD будет родителем следующего созданного коммита. Как правило, самое простое считать HEAD снимком вашего последнего коммита.
![Git commit](./img/изображение_2023-10-02_153207227.png)
* Сделаем изменения в файле и проверим статус:
```shell
# Делаем изменения и сохраняем
$ nano tets.py
# Проверям статус и видим что внесено изменение в наш файл
$ git log 
```
* Снова:
```shell
$ git add test.py
$ git commit -m "Change firts commit"
```
* На нашей ветке теперь два коммита
![2 commit](./img/изображение_2023-10-02_154502163.png)
* Видим что HEAD указывает на последний commit и для того чтобы нам откатиться к более старой версии нашего репозитория используем команду checkout:
```shell
# можно выделить ссылку коммита на который хотим перейти нажать колесико мыши и вуаля выделенная область копируется в наше поле ввода:) 
$ git checkout b8f46d02aaf7fdb87f633f99e4bf32b5b023ce45
# Или же мы можем переместиться на один или несколько коммитов назад
$ git checkout^
$ git checkout~<num>
# Можем зайти в файл и увидим его версию до изменений  
$ nano test.py
# Вернуться назад
$ git checkout master
```
![Fisrt commit](./img/изображение_2023-10-02_160341035.png)

## Github
**Настройка доступа к GitHub через ssh ключ**
* SSH (Secure SHell) - это протокол, который позволяет безопасно авторизоваться в различные сервисы, подключаться к удаленным терминалам, передавать по шифрованным каналам информацию. Очень распрастранен при работе с репозиториями. Использует пару ключей - публичный и приватный.
* [Расширенный материал по GitBush.](https://github.com/nnstu-appmath/kb/blob/5_git_introduction/SSH/connecting_to_github_with_SSH.md)
* Открывайте GitBash или терминал, вводите:
```shell
$ ssh-keygen -t ed25519 -b 4096
```
Вам будут заданы несколько вопросов:

Куда сохранить файл (Enter file in which to save...) - нажмите Enter и по умолчанию ключ будет назван id_ed25519 и сохранится в .ssh папке профиля текущего пользователя. (в Windows папки пользователя в C:/Users, в macOs/Linux папка пользователя в /home)

Введите кодовую фразу (Enter passphrase...) - опционально, кодовая фраза это элемент безопасности. Если ваш приватный ключ попадет в чужие руки, им не смогут воспользоваться пока не подберут кодовую фразу. Это даст вам больше времени для замены ключей и отказа от скомпрометированного ключа. Предлагаю в данный момент отказаться от ключевой фразы и просто нажать Enter.

Подтвердить кодовую фразу или ее отсутсвие, тоже нажав Enter.

* Заходи в папку где сохранились ключи, тот что .pub открываем с помощью блокнота и копируем содержимое.
* Заходим на [Github](https://github.com) регистрируемся или осуществляем логин если аккаунт уже есть.
* Далее заходим в настройки в разделе Access находим SSH and GPG keys
* Нажимаем New SSH key
* Называем его как удобно, в поле key вставляем скопированное ранее и нажимаем Add SSH key.
![New key](./img/изображение_2023-10-02_165521842.png)
* На картинке выше пример запуска команды для генерации ssh ключа:
```
$ ssh-keygen -t ed25519 -b 4096
```
**Создать пустой репозиторий на GitHub**
* Заходим в Your repositories нажимаем New
* Вводим название
* Отсальные поля опционально
* Нажимаем Create repository
* Далее будет такое окно:
![new repo](./img/изображение_2023-10-02_170200471.png)
* Выбираем ssh
* Копируем три команды и вставляем их в Git Bash.
![git push](./img/изображение_2023-10-02_172710037.png)
* Обновляем страницу и видим что наш файл успешно добавлен.
![new file](./img/изображение_2023-10-02_172953101.png)
* Команда
```
$ git remote 
```
Используется для управления удаленными репозиториями в Git. Она позволяет просматривать существующие удаленные репозитории, добавлять новые, удалять или переименовывать удаленные ссылки. При работе с командой `git remote` можно использовать различные опции, например, `add` для добавления новых удаленных репозиториев или `rename` для переименования существующих удаленных ссылок. Пример использования команды `git remote` может выглядеть так: 
```
$ git remote add origin https://github.com/username/repo.git
```
где `origin` - имя удаленной ссылки, а `https://github.com/username/repo.git` - URL адрес удаленного репозитория.
* [Подробнеее о git remote.](https://www.atlassian.com/ru/git/tutorials/syncing)

* Изменяем файл add commit и push, все по старой схеме только теперь это связано с github

![change](./img/изображение_2023-10-02_173333924.png)

* Видим изменение на git

**Создание новой ветки**
* Ветки в Git - это отдельные линии разработки, которые позволяют вам работать над разными версиями вашего проекта независимо друг от друга. Они полезны для создания новых функций, исправления ошибок и различных экспериментов, не затрагивая основную ветку разработки. Ветки позволяют команде разработчиков эффективно сотрудничать, управлять изменениями и объединять свою работу вместе для создания стабильной и функциональной версии проекта. Коммиты разных программистов объединяются — мёржатся (от англ. merge — сливать, соединять). У каждого коммита есть уникальный номер, он называется хешем, и комментарий, который описывает суть изменений. А все коммиты в одном проекте складываются в единую структуру — бранч (от англ. branch — отделение, ветка). Важное преимущество Git-проектов состоит ещё и в том, что код хранится и на сервере, и локально, то есть на компьютерах разработчиков. Это значит, что код нельзя случайно (или специально) удалить — всегда найдётся версия, из которой можно восстановить сразу всё.
* 
* В консоли вводим команду:
```shell
$ git checkout -b [название ветки]
# Переходим на эту ветку
$ git checkout new_branch
# Создаем изменения в файле
$ nano test.py
$ git add test.py
$ git commit -m "issue_1"
$ git push
```
![new_branch](./img/изображение_2023-10-02_174424085.png)

* Как видим сам git после команды push предлогает создать новую ветку на github
```shell
# Копируем и Enter
$ git push --set-upstream origin new_branch
```
* Заходим в нашу repo на сайте видим, что нам предлогаю создать pull_request

![pr](./img/изображение_2023-10-02_174839998.png)

* Нажимаем Compare_and_pull_request, далее все опционально, но я предлогаю просто нажать Create_pull_request
* Заходим в настройки, Collaborators, Add people

![](./img/изображение_2023-10-02_180015864.png)

* Добавляем коллегу по нику и тд:

![](./img/изображение_2023-10-02_175936962.png)

* Возвращаемся в pull_request и добавляем уже сюда нашего коллегу

![](./img/изображение_2023-10-02_180249108.png)

* Приглошаем его на code review через @
* Он комментирует код
![](./img/изображение_2023-10-02_181122143.png)

![](./img/изображение_2023-10-02_181221535.png)

![](./img/изображение_2023-10-02_181308525.png)

* Когда вы все обсудили согласовали, то можно делать merge - используется в Git, чтобы собрать воедино разветвленную историю. Команда git merge выполняет слияние отдельных направлений разработки, созданных с помощью команды git branch, в единую ветку.
 
![](./img/изображение_2023-10-02_181455974.png)

* Merge, confirm merge, delete branch.

## Merge
Для получения изменений из удаленного репозитория локально и осуществления слияния с текущей веткой, следует выполнить следующие шаги:

1. Переключитесь на ветку master или main (в зависимости от наименования вашей основной ветки) с помощью команды:
```
$ git checkout master
или
$ git checkout main
```
2. Затем выполните команду git pull, чтобы стянуть последние изменения из удаленного репозитория:
```
$ git pull
```
Эта команда автоматически запускает операцию git fetch, чтобы получить изменения с удаленного репозитория, а затем сливает их с текущей веткой.

Примеры команды: 
```
$ git fetch 
```
без слияния с текущей веткой:
1. Для стягивания изменений из удаленной ветки с именем develop без слияния с текущей веткой, вы можете использовать следующую команду:
```
$ git fetch origin develop
```
После выполнения этой команды, изменения будут доступны локально, но они не будут автоматически слиты с текущей веткой.
2. Чтобы просмотреть изменения в удаленной ветке feature-branch, не выполняя слияния, можно воспользоваться командой:
```
$ git fetch origin feature-branch
```
Эта команда загрузит последние изменения из удаленной ветки feature-branch, но не применит их к текущей ветке.

Теперь рассмотрим некоторые полезные темы, связанные с Git:
1. Конфликты при слиянии (merge conflicts): Если при слиянии веток возникают конфликты, это означает, что Git не может автоматически объединить изменения, так как они затрагивают одни и те же строки кода. В таких случаях необходимо вручную разрешить конфликты путем редактирования конфликтующих файлов и внесения необходимых изменений.
2. Откат изменений (reset, revert): Git предоставляет несколько способов откатить изменения. Команда git reset позволяет отменить коммиты и переместить указатель ветки на другой коммит. Команда git revert создает новый коммит, который отменяет изменения, внесенные определенным коммитом. Выбор между reset и revert зависит от того, что вы хотите достичь и какие изменения вы хотите откатить.
3. Git stash: Команда git stash позволяет временно сохранить незавершенные изменения в отдельном месте (в stash), чтобы переключиться на другую ветку без сохранения изменений в коммите. Это полезно, когда вы не готовы завершить текущую задачу, но хотите переключиться на другую задачу или ветку.

## Rebase
Git rebase представляет собой мощную команду в системе контроля версий Git, которая позволяет изменять историю коммитов. Она позволяет переписать историю коммитов, объединять коммиты, изменять порядок коммитов и многое другое. Git rebase может быть полезным инструментом при работе с ветками и слияниями коммитов.

Пример использования команды git rebase:
Предположим, у нас есть ветка под названием "feature" и мы хотим применить изменения, внесенные в основную ветку "master", на ветку "feature".

1. Перейдите на ветку "feature":
```
$ git checkout feature
```

2. Получите последние изменения из ветки "master":
```
$ git fetch
```

3. Выполните команду git rebase с указанием ветки, из которой вы хотите взять изменения (в данном случае "master"):
```
$ git rebase master
```

Git выполнит следующие действия:
- Отыщет общий предок последнего коммита из ветки "feature" и последнего коммита из ветки "master".
- Применит изменения из ветки "master" на ветку "feature" путем применения каждого коммита из "feature" поверх этого общего предка.

4. Разрешите возможные конфликты слияния, если они возникнут.

5. После разрешения конфликтов продолжите процесс ребейза:
```
$ git rebase --continue
```

6. После завершения ребейза ветка "feature" будет содержать изменения из ветки "master", примененные поверх общего предка. Вы можете продолжать работу с веткой "feature", включающей обновления из ветки "master".

Важно отметить, что команда git rebase переписывает историю коммитов, поэтому ее следует использовать осторожно и только в тех случаях, когда это необходимо. Она может быть полезна при поддержке чистой и линейной истории коммитов. Однако, если вы публикуете изменения, уже существующие в удаленном репозитории, не рекомендуется использовать git rebase, чтобы избежать конфликтов.

Использование git rebase требует хорошего понимания работы Git и его команд. Перед использованием команды git rebase рекомендуется освежить свои знания и попробовать ее на тестовом репозитории.

**Это была вся основная информация по git**

**Спасибо за внимание**
 
