
![](https://softico.ua/wp-content/uploads/2021/12/horizontal-logo-monochromatic-white.png)

[Docker](https://www.docker.com) — это открытая платформа для разработки, доставки и запуска приложений в слабо изолированной среде, называемой _контейнером_. 
Docker позволяет вам отделить ваши приложения от вашей инфраструктуры, чтобы вы могли быстро доставлять программное обеспечение. Воспользовавшись методологиями Docker для быстрой доставки, тестирования и развертывания кода, вы можете значительно сократить задержку между написанием кода и его запуском в рабочей среде.

Предшественниками контейнеров Docker были виртуальные машины. Виртуальная машина, как и контейнер, изолирует от внешней среды приложение и его зависимости. Однако контейнеры Docker обладают преимуществами перед виртуальными машинами. Так, они потребляют меньше ресурсов, их очень легко переносить, они быстрее запускаются и приходят в работоспособное состояние. В [этом](https://www.freecodecamp.org/news/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b) материале можно найти подробное сравнение контейнеров и виртуальных машин.

**Движок Docker (Docker Engine)** — это клиент-серверное приложение. Компания Docker разделила движок Docker на два продукта. [Docker Community Edition (CE)](https://docs.docker.com/get-docker/) — это бесплатное ПО. [Docker Enterprise](https://www.docker.com/products/business/) — это платная версия системы, дающая пользователям дополнительные возможности в области поддержки систем, управления ими и безопасности.
 
## Для чего можно использовать Docker?<br>
**Быстрая и последовательная доставка приложений**

Docker оптимизирует жизненный цикл разработки, позволяя разработчикам работать в стандартизированных средах, используя локальные контейнеры, которые предоставляют ваши приложения и службы. Контейнеры отлично подходят для рабочих процессов [непрерывной интеграции и непрерывной доставки (CI/CD)](https://habr.com/ru/company/otus/blog/515078/).<br>
[(Рекомендации по использованию Docker Hub для CI/CD)](https://docs-docker-com.translate.goog/ci-cd/best-practices/?_x_tr_sl=en&_x_tr_tl=ru&_x_tr_hl=ru)

**Адаптивное развертывание и масштабирование**

Платформа Docker на основе контейнеров позволяет выполнять переносимые рабочие нагрузки. Контейнеры Docker могут работать на локальном ноутбуке разработчика, на физических или виртуальных машинах в центре обработки данных, у облачных провайдеров или в различных средах.

Портативность и легкость Docker также упрощают динамическое управление рабочими нагрузками, масштабирование или удаление приложений и служб в соответствии с потребностями бизнеса почти в реальном времени.

**Запуск большего количества рабочих нагрузок на том же оборудовании**

Изоляция и безопасность позволяют запускать множество контейнеров одновременно на одном хосте. Контейнеры легкие и содержат все необходимое для запуска приложения, поэтому вам не нужно полагаться на то, что в данный момент установлено на хосте. Вы можете легко обмениваться контейнерами во время работы и быть уверенными, что все, с кем вы делитесь, получают один и тот же контейнер, который работает одинаково.

## Клиент Docker
Клиент Docker (Docker Client) — это основное средство, которое используют для взаимодействия с Docker. Так, при работе с интерфейсом командной строки Docker ([Docker Command Line Interface, CLI](https://docs.docker.com/engine/reference/commandline/cli/)), _в терминал вводят команды, начинающиеся с ключевого слова_ ```docker```, обращаясь к клиенту. Затем клиент использует API Docker для отправки команд демону Docker.

Демон Docker (Docker Daemon (```dockerd```)) — это сервер Docker, который ожидает запросов к API Docker. Демон Docker управляет образами, контейнерами, сетями и томами.

Тома Docker ([Docker Volumes](https://docs.docker.com/storage/volumes/)) представляют собой наиболее предпочтительный механизм постоянного хранения данных, потребляемых или производимых приложениями.<br>
![](https://docs.docker.com/engine/images/architecture.svg)

## Докер-объекты
**Образ** — это шаблон только для чтения с инструкциями по созданию контейнера Docker. Часто образ основано на другом образе с некоторой дополнительной настройкой. Например, вы можете создать образ, который основан на ubuntuобразе, но устанавливает веб-сервер Apache и ваше приложение, а также детали конфигурации, необходимые для запуска вашего приложения.

Вы можете создавать свои собственные образы или использовать только те, которые созданы другими и опубликованы в реестре. Чтобы создать собственный образ, вы создаете _Dockerfile_ с простым синтаксисом для определения шагов, необходимых для создания образа и его запуска. Каждая инструкция в _Dockerfile_ создает слой в образе. Когда вы меняете _Dockerfile_ и перестраиваете образ, перестраиваются только те слои, которые изменились. Это часть того, что делает образы такими легкими, маленькими и быстрыми по сравнению с другими технологиями виртуализации.  Например, если _Dockerfile_ описывает образ, который планируется использовать для решения задач машинного обучения, то в нём могут быть инструкции для включения в промежуточный слой такого образа библиотек NumPy, Pandas и Scikit-learn.

**[Файлы Dockerfile](https://habr.com/ru/company/ruvds/blog/439980/)**<br>
В файлах [Dockerfile](https://docs.docker.com/engine/reference/builder/) содержатся инструкции по созданию образа. С них, набранных заглавными буквами, начинаются строки этого файла. После инструкций идут их аргументы. Инструкции, при сборке образа, обрабатываются сверху вниз.

#### Инструкции Dockerfile

**FROM** — задаёт базовый (родительский) образ.<br>
Вот как работает инструкция FROM:

1. Она начинает новый шаг сборки.
2. Она не зависит от того, что было создано на предыдущем шаге сборки.
3. Она может использовать базовый образ, отличающийся от того, который применялся на предыдущем шаге.

**LABEL** — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.<br>
**ENV** — устанавливает постоянные переменные среды.<br>
**RUN** — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.<br>
**COPY** — копирует в контейнер файлы и папки.<br>
**ADD** — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.<br>
**CMD** — описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD.<br>
**WORKDIR** — задаёт рабочую директорию для следующей инструкции.<br>
**ARG** — задаёт переменные для передачи Docker во время сборки образа.<br>
**ENTRYPOINT** — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.<br>
**EXPOSE** — указывает на необходимость открыть порт.<br>
**VOLUME** — создаёт точку монтирования для работы с постоянным хранилищем.<br>

Пример файла Dockerfile:

```
FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
# Устанавливаем зависимости
RUN apk add --update git
# Задаём текущую рабочую директорию
WORKDIR /usr/src/my_app_directory
# Копируем код из локального контекста в рабочую директорию образа
COPY . .
# Задаём значение по умолчанию для переменной
ARG my_var=my_default_value
# Настраиваем команду, которая должна быть запущена в контейнере во время его выполнения
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
# Открываем порты
EXPOSE 8000
# Создаём том для хранения данных
VOLUME /my_volume
```
                            
**Контейнер** — это исполняемый экземпляр образа, вызванные к жизни образы Docker.

По умолчанию контейнер относительно хорошо изолирован от других контейнеров и своего хост-компьютера. Вы можете контролировать, насколько изолированы сеть контейнера, хранилище или другие базовые подсистемы от других контейнеров или от хост-компьютера.

Контейнер определяется своим образом, а также любыми параметрами конфигурации, которые вы предоставляете ему при создании или запуске. При удалении контейнера любые изменения его состояния, не сохраненные в постоянном хранилище, исчезают.

Для того чтобы запустить контейнер, нам нужен, во-первых, образ контейнера, во-вторых — среда, в которой установлен Docker, способная понять команду вида ```docker run image_name```. Эта команда создаёт контейнер из образа и запускает его.

_Как работает контейнер?_

Контейнер состоит из операционной системы, пользовательских файлов и метаданных. Как мы знаем, каждый контейнер создается из образа. Этот образ говорит докеру, что находится в контейнере, какой процесс запустить, когда запускается контейнер и другие конфигурационные данные. Docker образ доступен только для чтения. Когда docker запускает контейнер, он создает уровень для чтения/записи сверху образа (используя union file system), в котором может быть запущено приложение.

## Docker Hub
Если вы хотите дать возможность другим людям создавать контейнеры на основе вашего образа, вы можете отправить этот образ в облачное хранилище. Самым крупным реестром образов Docker является [Docker Hub](https://hub.docker.com). Он используется при работе с Docker по умолчанию.

При использовании команд ```docker pull``` или ```docker run``` требуемые образы извлекаются из настроенного репозитория. Когда вы используете ```docker push``` команду, ваш образ помещается в настроенный вами репозиторий.

**Репозиторием Docker** ([Docker Repository](https://docs.docker.com/docker-hub/repos/)) называют набор образов Docker, обладающих одинаковыми именами и разными тегами. **Теги** — это идентификаторы образов. Обычно в репозиториях хранятся разные версии одних и тех же образов.

## Команды

Основные моменты:
* Нужно выяснить — с чем вы имеете дело — с образом или с контейнером.
* Команды интерфейса командной строки Docker, используемые для управления чем-либо, начинаются с ключевого слова ```docker```, за которым идёт пробел, затем идёт указание на то, на что именно будет направлена некая команда, потом ещё один пробел, а потом следует сама команда. Например, именно так построена такая команда: ```docker container stop```.
* Если команда направлена на конкретный образ или контейнер, то в ней используется имя или идентификатор(ID) такого образа или контейнера.

#### [Основные команды для управления образами:](https://docs.docker.com/engine/reference/commandline/image/)

```
docker image my_command
```

**build** — сборка образа. <br>
Вот команда, которая позволяет собирать образы Docker:

```
docker image build -t my_repo/my_image:my_tag .
```

В данном случае создаётся образ с именем my_image, при его сборке используется файл Dockerfile, находящийся по указанному пути или URL. **Флаг -t** — это сокращение для --tag. Он указывает Docker на то, что создаваемому образу надо назначить предоставленный в команде тег. В данном случае это my_tag. Точка в конце команды указывает на то, что образ надо собрать с использованием файла Dockerfile, находящегося в текущей рабочей директории.

**push** — отправка образа в удалённый реестр.<br>
После входа в систему можно будет отправлять образы в реестр. Делается это так:

```
docker image push my_repo/my_image:my_tag
```

**ls** — вывод списка образов.<br>
**history** — вывод сведений о слоях образа.<br>
**inspect** — вывод подробной информации об образе, в том числе — сведений о слоях.<br>
**rm** — удаление образа.<br>
Вот команда, которая позволяет удалить все локальные образы:

```
docker image rm $(docker images -a -q) 
```

Пользоваться этой командой стоит с осторожностью, но надо заметить, что при её использовании образы, хранящиеся в удалённом репозитории, удалены не будут. В этом заключается одно из преимуществ хранения образов в репозиториях.

#### [Основные команды для управления контейнерами:](https://docs.docker.com/engine/reference/commandline/container/)

```
docker container my_command
```

**[create](https://docs.docker.com/engine/reference/commandline/container_create/)** — создание контейнера из образа. *Флаг -a* представляет собой краткую форму флага --attach. Этот флаг позволяет подключить контейнер к STDIN, STDOUT или STDERR.<br>
**start** — запуск существующего контейнера.<br>
**[run](https://docs.docker.com/engine/reference/commandline/container_run/)** — создание контейнера и его запуск.<br>
Вот пример ее использования:

```
docker container run -i -t -p 1000:8000 --rm my_image
```

*Флаг -i* — это сокращение для --interactive. Благодаря этому флагу поток STDIN поддерживается в открытом состоянии даже если контейнер к STDIN не подключён. *Флаг -t* — это сокращение для --tty. Благодаря этому флагу выделяется псевдотерминал, который соединяет используемый терминал с потоками STDIN и STDOUT контейнера. Для того чтобы получить возможность взаимодействия с контейнером через терминал нужно совместно использовать флаги -i и -t. *Флаг -p* представляет собой сокращение для --port. Порт — это интерфейс, благодаря которому контейнер взаимодействует с внешним миром. Конструкция 1000:8000 перенаправляет порт Docker 8000 на порт 1000 компьютера, на котором выполняется контейнер. Если в контейнере работает некое приложение, способное выводить что-то в браузер, то, для того, чтобы к нему обратиться, в нашем случае можно перейти в браузере по адресу localhost:1000. *Флаг -d* — это сокращение для --detach. Эта команда запускает контейнер в фоновом режиме. Это позволяет использовать терминал, из которого запущен контейнер, для выполнения других команд во время работы контейнера.

_Что происходит, когда запускается контейнер?_

Или с помощью программы docker, или с помощью RESTful API, docker клиент говорит docker демону запустить контейнер.

```
$ sudo docker run -i -t ubuntu /bin/bash
```

Минимальными требованиями для запуска контейнера являются следующие атрибуты:
* какой образ использовать для создания контейнера. В нашем случае ubuntu
* команду которую вы хотите запустить когда контейнер будет запущен. В нашем случае /bin/bash

_Что же происходит под капотом, когда мы запускаем эту команду?_

Docker, по порядку, делает следующее:
1. скачивает образ ubuntu: docker проверяет наличие образа ubuntu на локальной машине, и если его нет — то скачивает его с Docker Hub. Если же образ есть, то использует его для создания контейнера;
2. создает контейнер: когда образ получен, docker использует его для создания контейнера;
3. инициализирует файловую систему и монтирует read-only уровень: контейнер создан в файловой системе и read-only уровень добавлен образ;
4. инициализирует сеть/мост: создает сетевой интерфейс, который позволяет docker-у общаться хост машиной;
5. Установка IP адреса: находит и задает адрес;
6. Запускает указанный процесс: запускает ваше приложение;
7. Обрабатывает и выдает вывод вашего приложения: подключается и логирует стандартный вход, вывод и поток ошибок вашего приложения, что бы вы могли отслеживать как работает ваше приложение.

Теперь у вас есть рабочий контейнер. Вы можете управлять своим контейнером, взаимодействовать с вашим приложением.

**docker restart** — останавливает и запускает контейнер.<br>
**docker pause** — приостанавливает работающий контейнер.<br>
**docker unpause** — возобновит работу работающего контейнера.<br>
**docker attach** — подключится к запущенному контейнеру.<br>
**rename** - позволяет переименовать контейнер.<br>
**ls** — вывод списка работающих контейнеров. *Ключ -a* этой команды — это сокращение для --all. Благодаря использованию этого ключа можно вывести сведения обо всех контейнерах, а не только о выполняющихся. *Ключ -s* — это сокращение для --size. Он позволяет вывести размеры контейнеров.<br>
**inspect** — вывод подробной информации о контейнере.<br>
**logs** — вывод логов.<br>
**stop** — остановка работающего контейнера с отправкой главному процессу контейнера сигнала SIGTERM, и, через некоторое время, SIGKILL. У контейнера есть, по умолчанию, 10 секунд, на то, чтобы завершить работу.<br>
**kill** — остановка работающего контейнера с отправкой главному процессу контейнера сигнала SIGKILL. Если контейнер нужно остановить быстро, не заботясь о корректном завершении его работы, можно воспользоваться такой командой. В большинстве ситуаций, для остановки контейнеров рекомендуется использовать команду stop.<br>

Вот команда, которая позволяет быстро остановить все работающие контейнеры:

```
docker container kill $(docker ps -q) 
```

**rm** — удаление остановленного контейнера.<br>

Вот команда, которая позволяет удалить все контейнеры, которые на момент вызова этой команды не выполняются:

```
docker container rm $(docker ps -a -q)
```

Сначала контейнер создают, потом его запускают, или комбинируют эти два шага, используя команду вида ```docker run my_container```. После этого запускается контейнеризированное приложение. Потом контейнер останавливают командой ```docker stop my_container```. Для удаления контейнера используется команда ```docker rm my_container```.

Удаление старых контейнеров:

```
docker ps -a | grep 'weeks ago' | awk '{print $1}' | xargs docker rm
```

Удаление остановленных контейнеров:
```
docker rm -v $(docker ps -a -q -f status=exited)
```

#### Разные команды:<br>
**docker images** — показывает все изображения.<br>
**docker import** — создает образ из архива.<br>
**docker commit** — создает образ из контейнера, временно приостанавливая его, если он запущен.<br>
**docker rmi** — удаляет образ.<br>
**docker load** — загружает образ из tar-архива как STDIN, включая изображения и теги (начиная с версии 0.7).<br>
**docker save** — сохраняет изображение в tar-архив поток в STDOUT со всеми родительскими слоями, тегами и версиями (начиная с 0.7).<br>
**docker version** — вывод сведений о версиях клиента и сервера Docker.<br>
**docker login** — вход в реестр Docker. Она позволяет войти в учётную запись на Docker Hub. Для входа в систему вам понадобится ввести имя пользователя и пароль.<br>
**docker system prune** — удаление неиспользуемых контейнеров, сетей и образов, которым не назначено имя и тег.<br>
Вот пример её использования:

```
docker system prune -a --volumes
```

*Ключ -a* — сокращение для --all, позволяет удалить неиспользуемые образы, а не только те, которым не назначено имя и тег. *Ключ --volumes* позволяет удалить неиспользуемые тома.


## namespaces

Docker использует технологию namespaces для организации изолированных рабочих пространств, которые мы называем контейнерами. Когда мы запускаем контейнер, docker создает набор пространств имен для данного контейнера.

Это создает изолированный уровень, каждый аспект контейнера запущен в своем простанстве имен, и не имеет доступ к внешней системе.

Список некоторых пространств имен, которые использует docker:
**pid:** для изоляции процесса;<br>
**net:** для управления сетевыми интерфейсами;<br>
**ipc:** для управления IPC ресурсами. (ICP: InterProccess Communication);<br>
**mnt:** для управления точками монтирования;<br>
**utc:** для изолирования ядра и контроля генерации версий(UTC: Unix timesharing system).

## Control groups

Docker также использует технологию cgroups или контрольные группы. Ключ к работе приложения в изоляции, предоставление приложению только тех ресурсов, которые вы хотите предоставить. Это гарантирует, что контейнеры будут хорошими соседями. Контрольные группы позволяют разделять доступные ресурсы железа и если необходимо, устанавливать пределы и ограничения. Например, ограничить возможное количество памяти контейнеру.

## Полезные материалы:
[Docker Docs](https://docs.docker.com)
